class Srv
  var SRV_FIFO = NULL;
  var SRV_FIFO_FD = NULL;

  var CONNECTED_APPS = String_Type[0];
  var CONNECTED_PIDS = Integer_Type[0];
  var CUR_APP = NULL;
  var CUR_IND = -1;

  def go_idled () public proc
    This.exit (0);
  end

  def init ()
    SRV_FIFO = This.tmpdir + "/Session.fifo";
    if (-1 == mkfifo (SRV_FIFO, 0755))
      throw ClassError, "Srv::init::" + SRV_FIFO + " cannot crate fifo, " +
        errno_string (errno);
  end

  def app_at_exit (s)
    variable code = waitpid (s.pid, 0);

    variable ind = wherefirst_eq (CONNECTED_PIDS, s.pid);

    CONNECTED_PIDS[ind] = 0;
    CONNECTED_APPS[ind] = NULL;
    CONNECTED_PIDS = CONNECTED_PIDS[where (CONNECTED_PIDS)];
    CONNECTED_APPS = CONNECTED_APPS[wherenot (_isnull (CONNECTED_APPS))];
    CUR_IND = 0 == CUR_IND
      ? length (CONNECTED_APPS)
        ? length (CONNECTED_APPS) - 1
        : -1
      : CUR_IND - 1;

    () = close (s.fd);
    () = remove (s.fifo);
    assoc_delete_key (APPS[s.name], string (s.pid));
  end

  def at_exit ()
    variable i;
    _for i (0, length (CONNECTED_APPS) - 1)
      {
      variable app = CONNECTED_APPS[i];
      variable pid = CONNECTED_PIDS[i];
      variable s = APPS[app][string (pid)];
      Sock.send_int (s.fd, 1);
      }
  end

  def app_new (s) public proc
    variable apps = assoc_get_keys (APPS);
    variable retval;

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    () = Rline.commandcmp (s, apps);

    if (any (apps == s.argv[0]))
      Srv.connect_to_app (s.argv[0]);
    else
      return;

    forever
      {
      retval = Srv.mainloop ();
      if (1 == retval)
        {
        retval = Srv.reconnect_to_app (CUR_APP);
        if (1 == retval)
          break;
        }
      else if (2 == retval)
        Srv.connect_to_app (CUR_APP);
      else
        break;
      }

    Api.restore_screen ();
    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def get_connected_apps () proc
    [This.appname + "::" + string (Env->PID), array_map (
      String_Type, &sprintf, "%s::%d", CONNECTED_APPS, CONNECTED_PIDS)];
  end

  def app_reconnect (s) public proc
    variable apps = get_connected_apps ()[[1:]];
    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    () = Rline.commandcmp (s, apps);

    if (any (apps == s.argv[0]))
      {
      if (s.argv[0] == This.appname + "::" + string (Env->PID))
        return;

      Api.reset_screen ();
      variable retval = Srv.reconnect_to_app (s.argv[0]);
      if (1 == retval)
        {
        Api.restore_screen ();
        Rline.set (s);
        Rline.prompt (s, s._lin, s._col);
        return;
        }
      }
    else
      return;

    forever
      {
      retval = Srv.mainloop ();
      if (1 == retval)
        {
        retval = Srv.reconnect_to_app (CUR_APP);
        if (1 == retval)
          break;
        }
      else if (2 == retval)
        Srv.connect_to_app (CUR_APP);
      else
        break;
      }

    Api.restore_screen ();
    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def mainloop ()
    if (NULL == CUR_APP)
      return;

    variable tok = strtok (CUR_APP, "::");
    variable app = tok[0];
    variable pid = tok[1];
    variable s = APPS[app][pid];

    forever
      {
      variable retval = Sock.get_int (SRV_FIFO_FD);

      if (Api->GO_ATEXIT == retval)
        {
        self.app_at_exit (s);
        break;
        }

      if (Api->GO_IDLED == retval)
        {
        s.state |= Api->IDLED;
        break;
        }

      if (Api->APP_GET_CONNECTED == retval)
        {
        Sock.send_str_ar (SRV_FIFO_FD, s.fd, get_connected_apps ());
        continue;
        }

      if (Api->APP_RECON_OTH == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        CUR_APP = Sock.get_str (SRV_FIFO_FD);
        return 1;
        }

      if (Api->APP_CON_NEW == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        CUR_APP = Sock.get_str (SRV_FIFO_FD);
        return 2;
        }
      }

    0;
  end

  def reconnect_to_app (k)
    variable tok = strtok (k, "::");
    variable app = tok[0];
    variable pid = tok[1];
    if (app == This.appname && pid == string (Env->PID))
      {
      CUR_APP = NULL;
      return 1;
      }

    variable s = APPS[app][pid];
    CUR_APP = k;
    Sock.send_int (s.fd, 0);
    0;
  end

  def connect_to_app (app)
    variable clfifo = This.tmpdir + "/__" + app + "_client_" +
      string (_time)[[5:]] + ".fifo";

    () = mkfifo (clfifo, 0755);

    variable env = [Env.defenv (),
      "SESSION=1", "SESSION_WRFIFO=" + SRV_FIFO, "SESSION_RDFIFO=" + clfifo];

    variable clpid = (@__get_reference ("runapp")) ([app], env;bg);

    SRV_FIFO_FD = open (SRV_FIFO, O_RDONLY);
    variable clfifo_fd = open (clfifo, O_WRONLY);

    CONNECTED_APPS = [CONNECTED_APPS, app];
    CONNECTED_PIDS = [CONNECTED_PIDS, clpid];

    APPS[app][string (clpid)] = @App_Type;

    variable s = APPS[app][string (clpid)];
    s.fifo = clfifo;
    s.fd = clfifo_fd;
    s.pid = clpid;
    s.state = Api->CONNECTED;
    s.name = app;

    CUR_APP = app + "::" + string (s.pid);
    CUR_IND++;
  end
end
