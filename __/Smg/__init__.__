class Smg
  import slsmg

  var public LINES     = SLsmg_Screen_Rows;
  var public COLUMNS   = SLsmg_Screen_Cols;
  var public PROMPTROW = SLsmg_Screen_Rows - 2;
  var public MSGROW    = SLsmg_Screen_Rows - 1;

  var __COLOR__ = struct
    {
  normal = "white",
  error = "brightred",
  success = "brightgreen",
  warn = "brightmagenta",
  prompt = "yellow",
  border = "brightred",
  focus = "brightcyan",
  hlchar = "blackonyellow",
  hlregion = "white",
  topline = "blackonbrown",
  infofg = "blue",
  infobg = "brown",
  diffpl = "brown",
  diffmn = "brightred",
  visual = "blackonbrown",
  };

  var static IMG = List_Type[LINES - 2];
  var SMGINITED = 0;
  var SUSPENDSTATE = 0;

  def set_basic_color (field, color) proc
    variable colors =
      [
      "white", "red", "green", "brown", "blue", "magenta",
      "cyan", "lightgray", "gray", "brightred", "brightgreen",
      "yellow", "brightblue", "brightmagenta", "brightcyan",
      "blackongray", "blackonwhite", "blackonred", "blackonbrown",
      "blackonyellow", "brownonyellow", "brownonwhite", "blackongreen",
      "blackoncyan",
      ];

    set_struct_field (__COLOR__, field, wherefirst (colors == color));
  end

  def get_color (clr) proc
    get_struct_field (__COLOR__, clr);
  end

  def refresh ()
    slsmg_refresh ();
  end

  def init ()
    if (SMGINITED)
      return;

    slsmg_init_smg ();

    SMGINITED = 1;
  end

  def is_inited ()
    SMGINITED;
  end

  def suspend_state ()
    SUSPENDSTATE;
  end

  def at_exit ()
    ifnot (SMGINITED)
      return;

    slsmg_reset_smg ();
    SMGINITED = 0;
  end


  def suspend ()
    if (SUSPENDSTATE)
      return;

    slsmg_suspend_smg ();
    SUSPENDSTATE = 1;
  end

  def resume ()
    ifnot (SUSPENDSTATE)
      return;

    slsmg_resume_smg ();
    SUSPENDSTATE = 0;
  end

  def clear_and_redraw ()
    self.suspend ();
    self.resume ();
  end

  def setrc (row, col)
    slsmg_gotorc (row, col);
  end

  def setrcdr (row, col)
    slsmg_gotorc (row, col);
    slsmg_refresh ();
  end


  def getrc (row, col)
      [slsmg_get_row (), slsmg_get_column ()];
  end

  def char_at ()
    slsmg_char_at ();
  end

  def hlregion (clr, r, c, dr, dc)
      slsmg_set_color_in_region (clr, r, c, dr, dc);
  end

  def hlregiondr (clr, r, c, dr, dc)
    slsmg_set_color_in_region (clr, r, c, dr, dc);
    slsmg_refresh ();
  end

  def cls ()
    slsmg_cls ();
  end

  def addnstr (str, len)
    slsmg_write_nstring (str, len);
  end

  def addnstrdr (str, len, nr, nc)
    slsmg_write_nstring (str, len);
    setrcdr (self, nr, nc);
  end

  def atrcaddnstr (str, clr, row, col, len)
    slsmg_gotorc (row, col);
    slsmg_set_color (clr);
    slsmg_write_nstring (str, len);
  end

  def atrcaddnstrdr (str, clr, row, col, nr, nc, len)
    atrcaddnstr (self, str, clr, row, col, len);
    setrcdr (self, nr, nc);
  end

  def aratrcaddnstr (ar, clrs, rows, cols, len)
    array_map (Void_Type, &atrcaddnstr, self, ar, clrs, rows, cols, len);
  end

  def aratrcaddnstrdr (ar, clrs, rows, cols, nr, nc, len)
    array_map (Void_Type, &atrcaddnstr, self, ar, clrs, rows, cols, len);
    setrcdr (self, nr, nc);
  end

  def eraseeol ()
    slsmg_erase_eol ();
  end

  def atrceraseeol (row, col)
    slsmg_gotorc (row, col);
    slsmg_erase_eol ();
  end

  def atrceraseeoldr (row, col)
    atrceraseeol (self, row, col);
    slsmg_refresh ();
  end

  def set_img (lines, ar, clrs, cols)
    variable i;

    if (NULL == clrs)
      {
      clrs = Integer_Type[length (lines)];
      clrs[*] = 0;
      }

    if (NULL == cols)
      {
      cols = Integer_Type[length (lines)];
      cols[*] = 0;
      }

    if (NULL == ar)
      {
      ar = String_Type[length (lines)];
      ar[*] = " ";
      }

    _for i (0, length (lines) -1)
      IMG[lines[i]] = {ar[i], clrs[i], lines[i], cols[i]};
  end

  def restore (r, ptr, redraw)
    variable len = length (r);
    variable ar = String_Type[0];
    variable rows = Integer_Type[0];
    variable clrs = Integer_Type[0];
    variable cols = Integer_Type[0];
    variable columns = qualifier ("columns", COLUMNS);
    variable i;

    _for i (0, len - 1)
      {
      ar = [ar, IMG[r[i]][0]];
      clrs = [clrs, IMG[r[i]][1]];
      rows = [rows, IMG[r[i]][2]];
      cols = [cols, IMG[r[i]][3]];
      }

    aratrcaddnstr (self, ar, clrs, rows, cols, columns);

    ifnot (NULL == ptr)
      setrc (self, ptr[0], ptr[1]);

    ifnot (NULL == redraw)
      slsmg_refresh ();
    end

  def send_msg_dr (str, clr, row, col)
    variable
      lcol = NULL == col ? strlen (str) : col,
      lrow = NULL == row ? MSGROW : row;

    atrcaddnstrdr (self, str, clr, MSGROW, 0, lrow, lcol, COLUMNS);
  end

  def send_msg (str, clr)
    atrcaddnstr (self, str, clr, MSGROW, 0, COLUMNS);
  end

  var defclr = 11;
  var headerclr = 5;

  def write_completion_routine (ar, startrow)
    variable
      lheaderclr = qualifier ("headerclr", headerclr),
      len = length (ar),
      cmpl_lnrs = [startrow:startrow + len - 1],
      columns = qualifier ("columns", COLUMNS),
      clrs = Integer_Type[len],
      cols = Integer_Type[len];

    clrs[*] = qualifier ("clr", defclr);
    ifnot (NULL == qualifier ("header")) clrs[0] = lheaderclr;
    cols[*] = qualifier ("startcol", 0);

    aratrcaddnstr (self, ar, clrs, cmpl_lnrs, cols, columns);
    cmpl_lnrs;
  end

  def printtoscreen (ar, lastrow, len, cmpl_lnrs)
    ifnot (length (ar))
      {
      @len = 0;
      return @Array_Type[0];
      }

    variable i;
    variable lines = qualifier ("lines", lastrow - 2);
    variable origlen = @len;
    variable hlreg = qualifier ("hl_region");
    variable lar = @len < lines ? @ar : ar[[:lines - 1]];
    variable startrow = lastrow - (length (lar) > lines ? lines : length (lar));
    variable header = qualifier ("header");

    ifnot (NULL == header)  lar = [header, lar];

    @cmpl_lnrs = write_completion_routine (self, lar, startrow - (NULL == header ? 0 : 1)
      ;;__qualifiers ());

    ifnot (NULL == hlreg)
      if (Array_Type == typeof (hlreg))
        if (Integer_Type == _typeof (hlreg))
            hlregion (self, hlreg[0], hlreg[1], hlreg[2], hlreg[3], hlreg[4]);
        else if (Array_Type == _typeof (hlreg))
          _for i (0, length (hlreg) - 1)
            if (Integer_Type == _typeof (hlreg[i]))
              hlregion (self, hlreg[i][0], hlreg[i][1], hlreg[i][2], hlreg[i][3], hlreg[i][4]);

    @len = @len >= lines;

    if (qualifier_exists ("refresh"))
      setrcdr (self, lastrow - 1, strlen (lar)[-1] + 1);

    ar[[origlen >= lines ? lines - 1 : origlen:]];
  end

  def printstrar (ar, lastrow, len, cmpl_lnrs)
    variable
      orig = ar,
      chr;

    ar = printtoscreen (self, ar, lastrow, len, cmpl_lnrs;;
      struct {@__qualifiers (), refresh});

    if (@len)
      {
      send_msg_dr (self, "Press any key except tab to exit, press tab to scroll",
        2, NULL, NULL);

      chr = Input.getch (;disable_langchange);

      while ('\t' == chr)
        {
        restore (self, @cmpl_lnrs, NULL, NULL);

        @len = length (ar);

        ar = printtoscreen (self, ar, lastrow, len, cmpl_lnrs;;
          struct {@__qualifiers (), refresh});

        ifnot (@len)
          ar = orig;

        chr = Input.getch (;disable_langchange);
        }
      }

    ar;
  end

  def askprintstr (str, charar, cmp_lnrs)
    variable header = " ";
    variable headclr = headerclr;
    variable chr = NULL;
    variable type = typeof (str);
    variable ar = (any ([String_Type, BString_Type] == type))
      ? strchop (strtrim_end (str), '\n', 0)
      : Array_Type == type
        ? any ([BString_Type, String_Type] == _typeof (str))
          ? str
          : NULL
        : NULL;
    if (NULL == ar)
      throw ClassError, "Smg::askprintstr::argument should be B?String_Type ([])?";

    variable len = length (ar);

    if ('@' == ar[0][0])
      {
      header = substr (ar[0], 2, -1);
      ar = ar[[1:]];
      len--;
      headclr = qualifier ("headerclr", headerclr);
      }

    ar = printstrar (self, ar, PROMPTROW - 1, &len, cmp_lnrs;;
      struct {@__qualifiers, header = header, headerclr = headclr});

    ifnot (NULL == charar)
      {
      while (chr = Input.getch (), 0 == any (chr == charar));

      restore (self, @cmp_lnrs, NULL, 1);

      chr;
      }
  end

  def _pop_up_ (self, ar, row, col, ifocus) proc
    variable lar = array_map (String_Type, &sprintf, " %s", ar);

    variable i;
    variable len = length (lar);
    variable fgclr = qualifier ("fgclr", 5);
    variable bgclr = qualifier ("bgclr", 11);
    variable maxlen = max (strlen (lar)) + 1;

  %  if (maxlen > COLUMNS)
  %    _for i (0, len - 1)
  %      if (strlen (lar[i]) > COLUMNS)
  %        lar[i] = substr (lar[i], 1, COLUMNS);
  %
  %  if (maxlen > COLUMNS)
  %    col = 0;
  %  else
  %    while (col + maxlen > COLUMNS)
  %      col--;

    variable rows = [row:row + len - 1];
    variable clrs = Integer_Type[len];
    variable cols = Integer_Type[len];

    ifocus = ifocus > length (clrs) ? length (clrs) : ifocus;

    clrs[*] = bgclr;
    clrs[ifocus - 1] = fgclr;
    cols[*] = col;

    aratrcaddnstr (self, lar, clrs, rows, cols, maxlen);
    rows;
  end

  def pop_up (ar, row, col, ifocus)
    ifnot (length (ar))
      return Integer_Type[0];

    variable avail_lines = LINES - 4;
    variable lar;
    variable lrow = row;

    if (length (ar) > avail_lines)
      lar = ar[[:avail_lines - 1]];
    else
      lar = @ar;

    while (lrow--, lrow - 1 + length (lar) >= avail_lines);
    lrow++;

    return _pop_up_ (self, lar, lrow, col, ifocus;;__qualifiers ());
  end

  def get_screen_size ()
    SLsmg_Screen_Rows, SLsmg_Screen_Cols;
  end

  def __HLINE__ ()
    repeat (char (8212), COLUMNS);
  end

  beg
    array_map (Void_Type, &set_basic_color,
      ["normal", "error", "success", "warn", "prompt",
       "border", "focus", "hlchar",   "hlregion", "topline",
       "infofg", "infobg", "diffpl", "diffmn", "visual"
      ],
      [__COLOR__.normal, __COLOR__.error, __COLOR__.success, __COLOR__.warn,
       __COLOR__.prompt, __COLOR__.border, __COLOR__.focus, __COLOR__.hlchar,
       __COLOR__.hlregion, __COLOR__.topline, __COLOR__.infofg, __COLOR__.infobg,
       __COLOR__.diffpl, __COLOR__.diffmn, __COLOR__.visual]);

    SLsmg_Tab_Width = 1;
    array_map (Void_Type, &slsmg_define_color, [0:14:1],
      [
      "white", "red", "green", "brown", "blue", "magenta",
      "cyan", "lightgray", "gray", "brightred", "brightgreen",
      "yellow", "brightblue", "brightmagenta", "brightcyan"
      ], "black");

    array_map (Void_Type, &slsmg_define_color, [15:19:1],
      "black", array_map (String_Type, &substr,
      ["blackongray", "blackonwhite", "blackonred", "blackonbrown",
      "blackonyellow"], 8, -1));

    array_map (Void_Type, &slsmg_define_color, [20:21:1],
      "brown", array_map (String_Type, &substr,
      ["brownonyellow", "brownonwhite"], 8, -1));

    array_map (Void_Type, &slsmg_define_color, [22:24:1],
      "black", array_map (String_Type, &substr,
      ["blackongreen", "blackoncyan", "blackonblack"], 8, -1));

    array_map (Void_Type, &set_struct_field, __COLOR__, get_struct_field_names (__COLOR__),
    array_map (Integer_Type, &get_color, get_struct_field_names (__COLOR__)));

    set_img (NULL, [0:LINES - 3], NULL, NULL, NULL);
  end

  let COLOR = __COLOR__;
  let NOCOLOR = 24;
end
