class Scm
  let EXEC = Sys.which ("git");

  var funcs = Assoc.new (Array_Type,
    [
    "init", "branch", "status", "log", "diff", "add", "branchnew",
    "branchdelete", "branchchange", "commit", "commitall", "pull",
    "lastlog", "diffrevision", "logpatch", "applypatch", "merge",
    "generic",
    ],
    {
    [EXEC, "init"],
    [EXEC, "branch"],
    [EXEC, "status", "-s"],
    [EXEC, "log", "--pretty=format:commit: %h%n%B%ncommiter: %cn  %cD%n%n%>(4)%B%n", "--after="],
    [EXEC, "diff"],
    [EXEC, "add", "-v"],
    [EXEC, "branch"],
    [EXEC, "branch", "-d"],
    [EXEC, "checkout"],
    [EXEC, "commit", "-v", "--message="],
    [EXEC, "commit", "-a", "-v", "--message="],
    [EXEC, "pull"],
    [EXEC, "log", "-1", "HEAD", "-p"],
    [EXEC, "log", "--no-walk", "-p"],
    [EXEC, "log", "-p"],
    [EXEC, "apply", "-p1", "--verbose"],
    [EXEC, "merge"],
    [EXEC],
    });

  def __exec__ (argv, status) proc
    variable p = Proc.init (0, 1, 1);
    variable file = qualifier ("redir_to_file");

    ifnot (NULL == file)
      {
      p.stdout.file = file;
      variable flags = qualifier ("flags");

      ifnot (NULL == flags)
        p.stdout.wr_flags = flags;
      }

    @status = p.execv (argv, NULL);
    p;
  end

  def __fmt_output__ (buf) proc
    strtok (buf, "\n");
  end

  def __print__ (p, status) proc
    if (status.exit_status)
      IO.tostderr (__fmt_output__ (p.stderr.out);;__qualifiers);
    else
      if (NULL == p.stdout.file)
        IO.tostdout (__fmt_output__ (p.stdout.out);;__qualifiers);

    status.exit_status;
  end

  def generic (?)
    variable args = __pop_list (_NARGS - 1);
    pop ();

    args = list_to_array (args, String_Type);

    variable
      status,
      argv = [@funcs[_function_name], args],
      p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def status ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def lastlog ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def pull ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def diff ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def add (file)
    variable
      status,
      argv = [funcs[_function_name], file],
      p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def diffrevision (revision)
    variable
      status,
      argv = [funcs[_function_name], revision],
      p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def log ()
    variable
      status,
      argv = @funcs[_function_name];

    argv[-2] += repeat ("_", COLUMNS);
    argv[-1] += string (localtime (_time).tm_year + 1900 - 2);

    variable p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def applypatch (patch)
    variable
      status,
      p = __exec__ ([funcs[_function_name], patch], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def merge (branch)
    variable
      status,
      p = __exec__ ([funcs[_function_name], branch], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def logpatch ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def init ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def branch ()
    variable
      status,
      p = __exec__ (funcs[_function_name], &status);

    if (status.exit_status)
      {
      IO.tostderr (__fmt_output__ (p.stderr.out);;__qualifiers);
      return 1;
      }

    variable ar = strtrim_end (strchop (p.stdout.out, '\n', 0));
    ar = ar[where (strlen (ar))];

    variable curbranch = substr (ar[wherenot (array_map (
    Integer_Type, &strncmp, ar, "* ", 2))][0], 3, -1);
    ar = [
    sprintf ("Current tree has %d branches", length (ar)),
    repeat ("_", COLUMNS),
    strtrim_beg (strtrim_beg (ar, "*")),
    repeat ("_", COLUMNS),
    sprintf ("Current Branch: %s", curbranch, 2)
    ];

   IO.tostdout (ar;;__qualifiers);
   0;
  end

  def branchnew (branch)
    variable
      status,
      argv = [funcs[_function_name], branch],
      p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def branchdelete (branch)
    variable
      status,
      argv = [funcs[_function_name], branch],
      p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def branchchange (branch)
    variable
      status,
      argv = [funcs[_function_name], branch],
      p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def commit (?)
    variable
      files = __pop_list (_NARGS - 1);

    pop ();

    if (0 >= length (files) - 1)
      {
      IO.tostderr ("no file[s] provided");
      return 1;
      }

    variable
      msg = files[-1],
      status,
      argv = @funcs[_function_name];

    argv[-1] += msg;
    argv = [argv, list_to_array (files[[:-2]], String_Type)];

    variable p = __exec__ (argv, &status;;__qualifiers);

    __print__ (p, status;;__qualifiers);
  end

  def commitall (msg)
    variable
      status,
      argv = @funcs[_function_name];

    argv[-1] += msg;
    variable p = __exec__ (argv, &status;;__qualifiers);

   __print__ (p, status;;__qualifiers);
  end
end
