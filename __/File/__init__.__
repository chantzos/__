class File
  import pcre

  let FLAGS = Assoc.new (Integer_Type, [
    "<", ">>", ">", ">|", ">>|", "<>>", "<>", "<>>|", "<>|"], [
    O_RDONLY,                     % <
    O_WRONLY|O_APPEND,            % >>
    O_WRONLY|O_CREAT,             % >
    O_WRONLY|O_CREAT|O_TRUNC,     % >|
    O_WRONLY|O_CREAT|O_APPEND,    % >>|
    O_RDWR|O_APPEND,              % <>>
    O_RDWR|O_CREAT,               % <>
    O_RDWR|O_CREAT|O_APPEND,      % <>>|
    O_RDWR|O_CREAT|O_TRUNC,       % <>|
    ]);

  let PERM = Assoc.new (Integer_Type, [
    "PRIVATE", "_PRIVATE", "STATIC", "_STATIC", "__STATIC",
    "PUBLIC", "_PUBLIC", "__PUBLIC", "___PUBLIC"], [
    S_IRWXU,                                 % 0700
    S_IRUSR|S_IWUSR,                         % 0600
    S_IRWXU|S_IRWXG,                         % 0770
    S_IRWXU|S_IRGRP|S_IXGRP,                 % 0750
    S_IRUSR|S_IWUSR|S_IRGRP,                 % 0640
    S_IRWXU|S_IRWXG|S_IRWXO,                 % 0777
    S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, % 0755
    S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH,         % 0644
    S_IRUSR|S_IWUSR|S_IWGRP|S_IWOTH,         % 0622
    ]);

  fun copy (src, dest)
  fun copy_recursive (source, dest)
  fun copy_opts ()
  fun __copy__ (source, dest, st_source, st_dest, opts)
  fun are_same (filea, fileb)
  fun is_block (file)
  fun is_chr (file)
  fun is_elf (file)
  fun is_fifo (file)
  fun is_lnk (file)
  fun is_reg (file)
  fun is_sock (file)
  fun move (source, dest, opts)
  fun extract (archive, verbose, dir, strip)
  fun remove (file, interactive, isdir)

  def is_type (mode, type)
    NULL == mode ? 0 : stat_is (type, mode);
  end

  def read (file)
    variable fd;

    ifnot (FD_Type == typeof (file))
      {
      if (-1 == access (file, F_OK|R_OK))
        throw ClassError, sprintf ("IO_Read_Error::read, %S, %s", file,
          errno_string (errno));

      fd = open (file, O_RDONLY);

      if (NULL == fd)
        throw ClassError, sprintf ("IO::read file descriptor: %S", errno_string (errno));
      }
   else
     fd = file;

    variable buf;
    variable str = "";

    () = lseek (fd, qualifier ("offset", 0), qualifier ("seek_pos", SEEK_SET));

    while (read (fd, &buf, 4096) > 0)
      str += buf;

    str;
  end

  def readlines (file)
    variable
      end = qualifier ("end", NULL),
      fp = fopen (file, "r");

    if (NULL == fp)
      return NULL;

    ifnot (NULL == end)
      array_map (String_Type, &strtrim_end, fgetslines (fp, end), "\n");
    else
      array_map (String_Type, &strtrim_end, fgetslines (fp), "\n");
  end

  def __write__ (fd, str) proc
    if (-1 == write (fd, str))
      {
      IO.tostderr (qualifier ("file", ""), ": " + errno_string (errno));
      return -1;
      }

    0;
  end

  def write (file, str)
    variable type = typeof (str);
    if (any ([String_Type, BString_Type] == type))
      str = [str];
    else
      ifnot (Array_Type == type)
        type = Null_Type;
      else
        ifnot (any ([BString_Type, String_Type] == _typeof (str)))
          type = Null_Type;
        else
          ifnot (qualifier_exists ("n"))
            str += "\n";

    if (Null_Type == type)
      {
      IO.tostderr ("type of string should be B?String_Type []?");
      return -1;
      }

    variable fd =
      open (file, O_WRONLY|O_CREAT|O_TRUNC, qualifier ("flags", File->PERM["__PUBLIC"]));

    if (NULL == fd)
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    if (any (-1 == Array.map (Integer_Type, &__write__, fd, str;file = file)))
      return -1;

    if (-1 == close (fd))
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    0;
  end

  def append (file, str)
    if (-1 == access (file, F_OK|W_OK))
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    variable fd = open (file, O_WRONLY|O_APPEND);

    if (NULL == fd)
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    if (-1 == lseek (fd, 0, SEEK_END))
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    if (-1 == write (fd, str))
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    if (-1 == close (fd))
      {
      IO.tostderr (file + ": " + errno_string (errno));
      return -1;
      }

    0;
  end
end
