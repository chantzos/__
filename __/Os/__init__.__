class Os
  let HASHEDDATA = NULL;
  var do_cache = 1;
  var last_request_time = 0;
  var timeout = 30 * 60;
  var cached_passwd = NULL;

  def set_passwd_timeout (tim)
    ifnot (Integer_Type == typeof (tim))
      return;

    timeout = tim;
  end

  def getpasswd ()
    variable passwd = "";
    variable prompt = "password:";
    variable chr;

    Smg.atrcaddnstrdr (prompt, 0, MSGROW, 0, MSGROW, strlen (prompt), COLUMNS);

    while (chr = Input.getch (), chr != '\r')
      {
      if (any (Input->rmap.backspace == chr) && strlen (passwd))
        passwd = substr (passwd, 1, strlen (passwd) - 1);
      else
        passwd += char (chr);
      }

    Smg.send_msg (" ", 0);

    passwd;
  end

  def encryptpasswd (passwd)
    passwd = NULL == passwd ? self.getpasswd () : passwd;

    Crypt.encrypt (Rand.getstr ('0', 'z', 40), passwd);
  end

  def confirmpasswd (data, passwd)
    @passwd = self.getpasswd ();

    Crypt.decrypt (data, @passwd);
  end

  def authenticate (user, passwd)
    auth (user, passwd);
  end

  def __getpasswd ()
    if (do_cache)
      ifnot (qualifier_exists ("uncached"))
        ifnot (NULL == cached_passwd)
          if (last_request_time)
            if (_time - last_request_time < timeout)
              ifnot (self.authenticate (Env->USER, cached_passwd))
                {
                last_request_time = _time;
                return cached_passwd + "\n";
                }

    variable passwd, retval;

    ifnot (NULL == HASHEDDATA)
      {
      retval = self.confirmpasswd (HASHEDDATA, &passwd);
      if (NULL == retval)
        {
        passwd = NULL;
        Smg.send_msg_dr ("Authentication error", 1, NULL, NULL);
        }
      else
        passwd += "\n";
      }
    else
      {
      passwd = self.getpasswd ();

      if (-1 == self.authenticate (Env->USER, passwd))
        {
        Smg.send_msg_dr ("Authentication error", 1, NULL, NULL);
        passwd = NULL;
        }

      ifnot (NULL == passwd)
        {
        Os.let ("HASHEDDATA", self.encryptpasswd (passwd));
        passwd += "\n";
        }
      }

    ifnot (NULL == passwd)
      if (do_cache)
        {
        cached_passwd = strtrim_end (passwd);
        last_request_time = _time;
        }

    passwd;
  end

  fun login ()

  subclass Signal
    __init__
      send
    end

    def send (pid, sig)
    ifnot (Os.Pid.exists (pid))
      return 0;

    variable uid = Env->UID;

    variable match = Re.Array.match (Os.Pid.status (pid), "Uid:").lines;
    ifnot (length (match))
      return -1;

    match = strtok (match[0], ":")[1];

    if (atoi (strtok (match)[0]) == uid)
      return kill (pid, sig);

    variable passwd = qualifier ("passwd", Os.__getpasswd ());
    if (NULL == passwd)
      return -1;

    variable p = Proc.init (1, 0, 0);
    p.stdin.in = passwd;

    return p.execv ([Sys->SUDO_BIN, "-S", "-E", "-p", "", Sys->SLSH_BIN,
      Env->STD_LIB_PATH + "/proc/sendsignalassu.slc", string (sig),
      string (pid)], NULL).exit_status;
    end
  end

  subclass Pid
    __init__
      status
      exists
    end

    def status (pid)
      ifnot (self.exists (pid))
        return String_Type[0];

      ifnot (Sys->OS == "Linux")
        return String_Type[0];

      File.readlines ("/proc/" + string (pid) + "/status");
    end

    def exists (pid)
      0 == (kill (pid, 0)) || errno == EPERM;
    end
  end
end
