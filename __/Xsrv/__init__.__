class Xsrv
  import xsrv

  let XDIR = Env->TMP_PATH + "/X";
  let RDFIFO = XDIR + "/Svfifo";
  let WRFIFO = XDIR + "/Clfifo";
  let! WRFD = NULL;
  let! RDFD = NULL;
  let XAUTH_BIN = Sys.which ("xauth");
  let URXVTD_BIN = Sys.which ("urxvtd");
  let X_TERM_BIN = NULL == URXVTD_BIN ? Sys.which ("xterm") : Sys.which ("urxvtc");
  let SETXKBMAP_BIN = Sys.which ("setxkbmap");
  let ERR = 0xc8;
  let DESKNUM = 13;
  let! DESKTOP_CLASSES = struct
    {
    class =
      {
      ["__SHELL"],
      ["CMODULES", "XSRV_CLASS"],
      ["SHELL_ON_APP"],
      ["SHELL_ON___"],
      ["SHELL_ON_CLASS_A", "SHELL_ON_CLASS_B"],
      ["SLSH"],
      ["MAIL"],
      ["SHELL_ON_TMP"],
      ["HTML_DOCS"],
      ["VED_LIB"],
      String_Type[0],
      String_Type[0],
      String_Type[0],
      },
    __SHELL = X_TERM_BIN + " -name __SHELL -e " + Env->BIN_PATH +
        "/__shell",
    SHELL_ON_APP = "cd " + Env->SRC_APP_PATH + " && " +
        X_TERM_BIN + " -name SHELL_ON_APP",
    SHELL_ON_TMP = "cd /tmp && " + X_TERM_BIN + " -name SHELL_ON_TMP",
    SHELL_ON___ =  "cd " + Env->SRC_PATH  + " && " +
        X_TERM_BIN + " -name SHELL_ON___",
    SHELL_ON_CLASS_A = "cd " + Env->SRC_CLASS_PATH + " && " +
        X_TERM_BIN + " -name SHELL_ON_CLASS_A",
    SHELL_ON_CLASS_B = "cd " + Env->SRC_CLASS_PATH + " && " +
        X_TERM_BIN + " -name SHELL_ON_CLASS_B",
    CMODULES = X_TERM_BIN + " -name CMODULES -e __ved " + Env->SRC_C_PATH +
        "/xsrv-module.c",
    XSRV_CLASS = X_TERM_BIN + " -name XSRV_CLASS -e __ved " + Env->SRC_CLASS_PATH +
        "/Xsrv/__init__.__",
    MAIL = X_TERM_BIN + " -name MAIL -e mutt -y",
    HTML_DOCS = X_TERM_BIN + " -name HTML_DOCS -e elinks " +
      Env->HOME_PATH + "/htmldocs/docs.html",
    SLSH = X_TERM_BIN + " -name SLSH -e slsh",
    VED_LIB = X_TERM_BIN + " -name VED_LIB -e __ved " + Env->SRC_CLASS_PATH +
      "/Ved/__init__.__",
    };

  include! __init__ from Xlocalxsrv as Xsrv

  % should be replaced by md5sum?
  def __xget_cookie () proc
    variable mc = Sys.which ("mcookie");
    if (NULL == mc)
      return NULL;

    variable buf, fp = popen (mc, "r");
    () = fgets (&buf, fp);
    strtrim_end (buf);
  end

  def X_startup () public proc
    ifnot (NULL == URXVTD_BIN)
      () = system (URXVTD_BIN + " -q -f -o &");

    variable cookie = __xget_cookie ();
    if (NULL != cookie && NULL != XAUTH_BIN)
      {
      variable tmp = File.mktmp (Env->TMP_PATH + "/X", "serverauth");
      ifnot (NULL == tmp)
        {
        putenv ("XAUTHORITY=" + tmp.file);
        () = system (XAUTH_BIN + " add " + getenv ("DISPLAY") + " . " + cookie);
        }
      }

    ifnot (NULL == SETXKBMAP_BIN)
      () = system (SETXKBMAP_BIN + " -layout \"us,el\" -option \"grp:alt_space_toggle\"");

    sleep (0.2);
    () = system (X_TERM_BIN + " -name __SHELL -e " + Env->BIN_PATH +
        "/__shell &");
  end

  def invalid_fun () proc
    Sock.send_int (WRFD, ERR);
  end

  var FUNS = Assoc_Type[Ref_Type, &invalid_fun];

  def getdeskclassnames () proc
    Sock.send_int (WRFD, 1);
    variable did = Sock.get_int (RDFD);
    variable ar = XGetDeskClassNames (did);
    if (NULL == ar)
      ar = String_Type[0];

    Sock.send_str_ar (RDFD, WRFD, ar);
  end

  def Srv_interp () public proc
    Xsrv.let ("WRFD", open (WRFIFO, O_WRONLY));
    Xsrv.let ("RDFD", open (RDFIFO, O_RDONLY));
    (@FUNS[Sock.get_str (RDFD)]);
  end

  def Srv_set_modes () public proc
    variable ar = Integer_Type[DESKNUM];
    ar++;
    ar[10]++;
    ar;
  end

  def Srv_set_desktops () public proc
    DESKNUM;
  end

  def Srv_on_desktop_change (did) public proc
    variable ar = XGetDeskClassNames (did);
    variable cls = DESKTOP_CLASSES.class[did];
    ifnot (length (cls))
      return;

    if (NULL == ar)
      ar = String_Type[0];

    variable i, p;
    _for i (0, length (cls) - 1)
      {
      if (any (ar == cls[i]))
        continue;
      p = get_struct_field (DESKTOP_CLASSES, cls[i]);
      () = system (p);
      }
  end

  def start ()
    Xstart ();

    variable xauthfile = getenv ("XAUTHORITY");
    ifnot (NULL == xauthfile)
      () = remove (xauthfile);

    ifnot (access (RDFIFO, F_OK))
      () = remove (RDFIFO);

    ifnot (access (WRFIFO, F_OK))
      () = remove (WRFIFO);
  end

  beg
    ifnot (access (XDIR, F_OK))
      {
      ifnot (Dir.isdirectory (XDIR))
        This.err_handler (XDIR + ": not a directory");
      }
    else
      if (-1 == Dir.make (XDIR, File->PERM["PRIVATE"];strict))
        This.err_handler ("cannot create directory: " + XDIR);

    ifnot (access (RDFIFO, F_OK))
      {
      ifnot (File.is_fifo (RDFIFO))
        This.err_handler (RDFIFO + ": not a fifo file");
      }
    else
      if (-1 == mkfifo (RDFIFO, File->PERM["PRIVATE"]))
        This.err_handler ("cannot create fifo: " + RDFIFO);

    ifnot (access (WRFIFO, F_OK))
      {
      ifnot (File.is_fifo (WRFIFO))
        This.err_handler (WRFIFO + ": not a fifo file");
      }
    else
      if (-1 == mkfifo (WRFIFO, File->PERM["PRIVATE"]))
        This.err_handler ("cannot create fifo: " + WRFIFO);

    FUNS["getdeskclassnames"] = &getdeskclassnames;

  end
end
