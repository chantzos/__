class Xsrv
  import xsrv

  let XDIR = Env->TMP_PATH + "/X";
  let RDFIFO = XDIR + "/Svfifo";
  let WRFIFO = XDIR + "/Clfifo";
  let! WRFD = NULL;
  let! RDFD = NULL;
  let XAUTH_BIN = Sys.which ("xauth");
  let URXVTD_BIN = Sys.which ("urxvtd");
  let X_TERM_BIN = NULL == URXVTD_BIN ? Sys.which ("xterm") : Sys.which ("urxvtc");
  let SETXKBMAP_BIN = Sys.which ("setxkbmap");
  let ERR = 0xc8;
  let DESKNUM = 13;
  % samples, those can be set on SRC_PATH/local/__/Xlocalxsrv/__init.__ instead
  let! DESKTOP_CLASSES = struct
    {
    class =
      {
      ["__SHELL"],
      },
    __SHELL = X_TERM_BIN + " -name __SHELL -e " + Env->BIN_PATH +
        "/__shell",
    };
 let! ON_MAP =
    {
    struct {class = "HTOP", desk = 13, follow = 1},
    };

  include! __init__ from Xlocalxsrv as Xsrv

  % should be replaced by md5sum?
  def __xget_cookie () proc
    variable mc = Sys.which ("mcookie");
    if (NULL == mc)
      return NULL;

    variable buf, fp = popen (mc, "r");
    () = fgets (&buf, fp);
    strtrim_end (buf);
  end

  def X_startup () public proc
    ifnot (NULL == URXVTD_BIN)
      () = system (URXVTD_BIN + " -q -f -o &");

    variable cookie = __xget_cookie ();
    if (NULL != cookie && NULL != XAUTH_BIN)
      {
      variable tmp = File.mktmp (Env->TMP_PATH + "/X", "serverauth");
      ifnot (NULL == tmp)
        {
        putenv ("XAUTHORITY=" + tmp.file);
        () = system (XAUTH_BIN + " add " + getenv ("DISPLAY") + " . " + cookie);
        }
      }

    ifnot (NULL == SETXKBMAP_BIN)
      () = system (SETXKBMAP_BIN + " -layout \"us,el\" -option \"grp:alt_space_toggle\"");

    sleep (0.2);
    () = system (X_TERM_BIN + " -name __SHELL -e " + Env->BIN_PATH +
        "/__shell &");
  end

  def invalid_fun () proc
    Sock.send_int (WRFD, ERR);
  end

  var FUNS = Assoc_Type[Ref_Type, &invalid_fun];

  def getdeskclassnames () proc
    Sock.send_int (WRFD, 1);
    variable did = Sock.get_int (RDFD);
    variable ar = XGetDeskClassNames (did);
    if (NULL == ar)
      ar = String_Type[0];

    Sock.send_str_ar (RDFD, WRFD, ar);
  end

  def Srv_interp () public proc
    Xsrv.let ("WRFD", open (WRFIFO, O_WRONLY));
    Xsrv.let ("RDFD", open (RDFIFO, O_RDONLY));
    (@FUNS[Sock.get_str (RDFD)]);
  end

  def Srv_set_onmap () public proc
    __push_list (ON_MAP);
    length (ON_MAP);
  end

  def Srv_set_modes () public proc
    variable ar = Integer_Type[DESKNUM];
    ar++;
    ar[10]++;
    ar;
  end

  def Srv_set_desktops () public proc
    DESKNUM;
  end

  def Srv_on_desktop_change (did) public proc
    variable ar = XGetDeskClassNames (did);
    variable cls = DESKTOP_CLASSES.class[did];
    ifnot (length (cls))
      return;

    if (NULL == ar)
      ar = String_Type[0];

    variable i, p;
    _for i (0, length (cls) - 1)
      {
      if (any (ar == cls[i]))
        continue;
      p = get_struct_field (DESKTOP_CLASSES, cls[i]);
      () = system (p);
      }
  end

  def start ()
    Xstart ();

    variable xauthfile = getenv ("XAUTHORITY");
    ifnot (NULL == xauthfile)
      () = remove (xauthfile);

    ifnot (access (RDFIFO, F_OK))
      () = remove (RDFIFO);

    ifnot (access (WRFIFO, F_OK))
      () = remove (WRFIFO);
  end

  beg
    ifnot (access (XDIR, F_OK))
      {
      ifnot (Dir.isdirectory (XDIR))
        This.err_handler (XDIR + ": not a directory");
      }
    else
      if (-1 == Dir.make (XDIR, File->PERM["PRIVATE"];strict))
        This.err_handler ("cannot create directory: " + XDIR);

    ifnot (access (RDFIFO, F_OK))
      {
      ifnot (File.is_fifo (RDFIFO))
        This.err_handler (RDFIFO + ": not a fifo file");
      }
    else
      if (-1 == mkfifo (RDFIFO, File->PERM["PRIVATE"]))
        This.err_handler ("cannot create fifo: " + RDFIFO);

    ifnot (access (WRFIFO, F_OK))
      {
      ifnot (File.is_fifo (WRFIFO))
        This.err_handler (WRFIFO + ": not a fifo file");
      }
    else
      if (-1 == mkfifo (WRFIFO, File->PERM["PRIVATE"]))
        This.err_handler ("cannot create fifo: " + WRFIFO);

    FUNS["getdeskclassnames"] = &getdeskclassnames;

  end
end
