class Array
  def istype (a, type)
    ifnot (typeof (a) == Array_Type)
      return 0;

    ifnot (NULL == type)
      ifnot (_typeof (a) == type)
        return 0;
    1;
  end

  def to_list (a)
    return {self.push (a)};
  end

  def push (a)
    variable i;
    _for i (0, length (a) - 1)
      a[i];
  end

  % unique-shift code from upstream
  def shift (x, n)
    variable len = length (x);
    ifnot (len)
      return x;

    n = len + n mod len;
    x[[n:n+len-1] mod len];
  end

  def unique (a)
    variable
      i,
      j,
      len = length (a);

    if (len <= 1)
      return [0:len-1];

  	 i = array_sort (a);

    a = a[i];

    if (a[0] == a[-1])
     return [0];

    j = where (shift (NULL, a, -1) != a);
    i[j];
  end

  def getsize (ar)
    ifnot (istype (self, ar, String_Type))
      throw ClassError, "Array::getsize::array should be of String_Type[]";

    int (sum (strbytelen (ar)) + length (ar));
  end

  def map (?)
    if (_NARGS < 4)
      throw ClassError, "NumArgsError::" + _function_name +
        "::_NARGS should be at least 4 and are " + string (_NARGS), NULL;

    variable arglen = _NARGS - 3;
    variable args = __pop_list (arglen);
    variable ref = ();
    variable dtp = ();
    pop ();

    if (NULL == ref || 0 == __is_callable (ref) || typeof (dtp) != DataType_Type)
      throw ClassError, "TypeMismatchError::" +  _function_name +
        "::" + string (ref) + " should be of Ref_Type and it is " + string (typeof (ref)) , NULL;

    variable i;
    variable llen;
    variable len = 0;
    variable dtps = DataType_Type[arglen];

    _for i (0, arglen - 1)
      {
      dtps[i] = typeof (args[i]);
      if (Array_Type == dtps[i] || List_Type == dtps[i])
        {
        llen = length (args[i]);
        ifnot (len)
          len = llen;
        else
          ifnot (llen == len)
            throw ClassError, "ArrayMapInvalidParmError::" + _function_name +
              "::arrays have different length", NULL;
        }
      }

    ifnot (len)
      throw ClassError, "ArrayMapTypeMismatchError::" +  _function_name +
        "::at least one argumrnt should be Array or List Type", NULL;

    variable l;
    variable ii;
    variable r;

    ifnot (Void_Type == dtp)
      variable at = dtp[len];

    _for i (0, len - 1)
      {
      l = {};

      _for ii (0, arglen - 1)
        if (Array_Type == dtps[ii] || List_Type == dtps[ii])
          list_append (l, args[ii][i]);
        else
          list_append (l, args[ii]);

      try
        {
        (@ref) (__push_list (l);;__qualifiers ());
        }
      catch AnyError:
        throw ClassError, "ArrayMapRunTimeError::" + _function_name + ":: error while executing "
          + string (ref), __get_exception_info;

      ifnot (Void_Type == dtp)
        {
        r = ();

        ifnot (typeof (r) == dtp)
          throw ClassError, "ArrayMapTypeMismatchError::" + _function_name + "::" + string (ref) +
            " returned " + string (typeof (r)) + "instead of " + string (dtp), NULL;

        at[i] = r;
        }
     }

    ifnot (Void_Type == dtp)
      ifnot (qualifier_exists ("discard"))
        at;
  end

  def delete_at (arr, at_index)
    ifnot (self.istype (@arr, NULL))
      return;

    variable len = length (@arr);
    if (at_index < 0)
      at_index = len + at_index;

    if (len - 1 < at_index || at_index < 0)
      return;

    @arr = [(@arr)[[0:at_index-1]], (@arr)[[at_index+1:]]];
  end

  def append (?)
    variable arr, at_index, val;

    if (3 == _NARGS)
      {
      val = (); arr = (); at_index = length (@arr);
      }
    else if (4 == _NARGS)
      {
      val = ();
      at_index = ();
      arr = ();
      }
    else
      return;

    variable self = ();

    ifnot (self.istype (@arr, typeof (val)))
      return;

    variable len = length (@arr);
    if (at_index < 0)
      at_index = len + at_index;

    if (len < at_index || at_index < -1)
      return;

    if (len == at_index)
      @arr = [@arr, val];
    else if (-1 == at_index)
      @arr = [val, @arr];
    else
      @arr = [(@arr)[[0:at_index]], val, (@arr)[[at_index+1:]]];
  end

  def insert (?)
    variable arr, at_index, val;

    if (3 == _NARGS)
      {
      val = (); arr = (); at_index = 0;
      }
    else if (4 == _NARGS)
      {
      val = ();
      at_index = ();
      arr = ();
      }
    else
      return;

    variable self = ();

    ifnot (self.istype (@arr, typeof (val)))
      return;

    variable len = length (@arr);
    if (at_index < 0)
      at_index = len + at_index;

    if (len < at_index || at_index < 0)
      return;

    if (len == at_index)
      @arr = [@arr, val];
    else
      @arr = [(@arr)[[0:at_index-1]], val, (@arr)[[at_index:]]];
  end

  def join (ar, bar)
    if (any (0 == [self.istype (@ar, NULL), self.istype (bar, NULL)]))
      return;

    ifnot (_typeof (@ar) == _typeof (bar))
      return;

   @ar = [@ar, bar];
  end
end
