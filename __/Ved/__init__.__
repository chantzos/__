class Ved
  var public Vundo;

  typedef Ftype
    _i,_ii,_len,_chr,_type,_fname,_abspath,_fd,_flags,_maxlen,_indent,
    _linlen,_avlins,_findex,_index,_shiftwidth,_expandtab,_undolevel,
    _autoindent,_dir,_autochdir,_is_wrapped_line,
    undo, undoset, ptr, rows, cols, clrs, lins, lnrs, vlins,lines,
    st_,
    vedloop,vedloopcallback,
    ved,
    draw, lexicalhl, autoindent, pairs,
  end

  typedef Insert
    chr,
    lnr,
    prev_l,
    next_l,
    modified,
  end

  typedef Pos
    _i,
    _index,
    _findex,
    ptr,
  end

  typedef Wind
    cur_frame,
    frame_rows,
    frame_names,
    frames,
    buffers,
    bufnames,
    rline,
    name,
    dir,
  end

  var vis = struct
    {
    _i,cur,ptr,mode,
    clr = Smg->COLOR.visual,
    l_mode,l_down,l_up,l_page_up,l_page_down,
    l_keys = ['w', 's', 'y', 'Y', 'd', '>', '<', 'g', 'G', Input->DOWN, Input->UP,
      Input->PPAGE, Input->NPAGE, Input->CTRL_f, Input->CTRL_b],
    c_mode,c_left,c_right,
    c_keys = ['y', 'd', Input->DOWN, Input->RIGHT, Input->UP, Input->LEFT],
    bw_mode,bw_down,bw_up,bw_left,bw_right,bw_maxlen,
    bw_keys = ['x', 'I', 'i', 'd', 'y', 'r', 'c', Input->DOWN, Input->UP, Input->RIGHT, Input->LEFT],
    needsdraw,startrow,startlnr,startcol,startindex,
    vlins,lnrs,linlen,lines,sel,at_exit,
    };

  let VED_DIR = Env->TMP_PATH + "/ved/" + string (Env->PID);
  let EL_MAP = [902, [904:906], 908, [910:929], [931:937], [945:974]];
  let EN_MAP = [['a':'z'], ['A':'Z']];
  let MAPS   = [EL_MAP, EN_MAP];
  let WCHARS = array_map (String_Type, &char, [['0':'9'], EN_MAP, EL_MAP, '_']);
  let DEFINED_UPPER_CASE = ['+', ',', '}', ')', ':'];
  let DEFINED_LOWER_CASE = ['-', '.', '{', '(', ';'];

  var VED_INFOCLRFG = Smg->COLOR.infofg;
  var VED_INFOCLRBG = Smg->COLOR.infobg;
  var VED_PROMPTCLR = Smg->COLOR.prompt;
  var VED_PREV_WIND;
  var VED_PREV_BUFINDEX;
  var MARKS  = Assoc_Type[Pos_Type];

  var public VED_WIND = Assoc_Type[Wind_Type];
  var public FTYPES = Assoc_Type[Integer_Type];
  var public REG    = Assoc_Type[String_Type];
  var public VED_ROWS = [1:LINES - 3];
  var public VED_MODIFIED = 0x01;
  var public VED_ONDISKMODIFIED = 0x02;
  var public VED_RDONLY = 0x04;
  var public VED_CUR_WIND = NULL;
  var public VED_ISONLYPAGER = 0;
  var public VED_RLINE = 1;
  var public UNDELETABLE = String_Type[0];
  var public SPECIAL = String_Type[0];

  beg
    Sys.let ("XCLIP_BIN", Sys.which ("xclip"));
  end

  var public s_histfile = Env->USER_DATA_PATH + "/.__" + Env->USER + "_ved_search_history";
  var public s_histindex = NULL;
  var public s_history = {};

  def _invalid () proc
    pop ();
  end

  var public VED_PAGER = Assoc_Type[Ref_Type, &_invalid];
  var public VEDCOUNT;

  def build_ftype_table () proc
    variable i;
    variable ii;
    variable ft;
    variable nss = [Env->USER_PATH, Env->STD_DATA_PATH];

    _for i (0, length (nss) - 1)
      {
      ft = listdir (nss[i] + "/ftypes");
      if (NULL == ft)
        continue;

      _for ii (0, length (ft) - 1)
        if (Dir.isdirectory (nss[i] + "/ftypes/" + ft[ii]))
          FTYPES[ft[ii]] = 0;
      }
  end

  beg
    build_ftype_table ();

    if (-1 == Dir.make_parents (VED_DIR, File->PERM["PRIVATE"]))
      throw ClassError, "Ved::ATINIT::" + VED_DIR + ": cannot make directory, "
        + errno_string (errno);
  end

  def getXsel () public proc
    "";
  end

  def seltoX (sel) public proc
  end

  def topline () public proc
  end

  def toplinedr () public proc
  end

  def __eval () public proc
  end

  def insert () proc
  end

  def set_modified (s) public proc
    s._flags |= VED_MODIFIED;
  end

  def get_ftype (fn)
    variable ftype = substr (path_extname (fn), 2, -1);
    ifnot (any (assoc_get_keys (FTYPES) == ftype))
      if ("mutt-" == substr (path_basename (fn), 1, 5))
        ftype = "mail";
      else
        ftype = "txt";

    ftype;
  end

  def! init_ftype (ftype)
    ifnot (FTYPES[ftype])
      FTYPES[ftype] = 1;

    variable type = @Ftype_Type;

    variable f = Env->USER_DATA_PATH + "/ftypes/" + ftype + "/" +
      ftype + "_functions";

    if (-1 == access (f + ".slc", F_OK))
      f = Env->STD_DATA_PATH + "/ftypes/" + ftype + "/" + ftype + "_functions";

    Load.file (f, NULL);

    type._type = ftype;
    type;
  end

  def __get_null_str (indent) proc
    sprintf ("%s\000", repeat (" ", indent));
  end

  def write_line (fp, line, indent) proc
    line = substr (line, indent + 1, -1);
    return fwrite (line, fp);
  end

  def __vgetlinestr (s, line, ind) proc
    substr (line, ind + s._indent, s._linlen);
  end

  def __vwritetofile (file, lines, indent, bts) public proc
    variable
      i,
      retval,
      fp = fopen (file, NULL == qualifier ("append") ? "w" : "a+");

    if (NULL == fp)
      return errno;

    _for i (0, length (lines) - 1)
      if (retval = write_line (fp, lines[i] + "\n", indent), retval == -1)
        return errno;
      else
        @bts += retval;

    if (-1 == fclose (fp))
      return errno;

    0;
  end

  def _initrowsbuffvars_ (s) proc
    s.cols = Integer_Type[length (s.rows)];
    s.cols[*] = 0;

    s.clrs = Integer_Type[length (s.rows)];
    s.clrs[*] = 0;
    s.clrs[-1] = VED_INFOCLRFG;

    s._avlins = length (s.rows) - 2;
  end

  def _addbuf_ (s) proc
    ifnot (path_is_absolute (s._fname))
      s._abspath = getcwd () + s._fname;
    else
      s._abspath = s._fname;

    variable w = Ved.get_cur_wind ();

    if (any (s._abspath == w.bufnames))
      return;

    w.buffers[s._abspath] = s;
    w.bufnames = [w.bufnames,  s._abspath];
    w.buffers[s._abspath]._dir = realpath (path_dirname (s._abspath));
  end

  def waddlineat (s, line, clr, row, col, len) proc
    Smg.atrcaddnstr (line, clr, row, col, len);
    s.lexicalhl ([line], [row]);
  end

  def waddline (s, line, clr, row) proc
    Smg.atrcaddnstr (line, clr, row, s._indent, s._linlen);
    s.lexicalhl ([line], [row]);
  end

  def _set_clr_ (s, clr, set) proc
    s.clrs[-1] = clr;
    Smg->IMG[s.rows[-1]][1] = clr;
    if (set)
      Smg.hlregion (clr, s.rows[-1], 0, 1, COLUMNS);
  end

  def __vset_clr_fg (s, set) public proc
    _set_clr_ (s, VED_INFOCLRFG, set);
  end

  def __vset_clr_bg (s, set) public proc
    _set_clr_ (s, VED_INFOCLRBG, set);
  end

  def framesize (frames) proc
    variable f = Integer_Type[frames];
    variable ff = Array_Type[frames];
    variable len = length (VED_ROWS);

    f[*] = len / frames;
    f[0] += len mod frames;

    variable i;
    variable istart = 0;
    variable iend;

    _for i (0, length (f) - 1)
      {
      iend = istart + f[i] - 1;
      ff[i] = VED_ROWS[[istart:iend]];
      istart = iend + 1;
      }

    ff;
  end

  def _vedloopcallback_ (s) proc
    (@VED_PAGER[string (s._chr)]) (s);
  end

  def _loop_ (s) proc
    variable ismsg = 0;
    variable rl;

    forever
      {
      s = Ved.get_cur_buf ();
      VEDCOUNT = -1;
      s._chr = Input.getch (;disable_langchange);

      if ('1' <= s._chr <= '9')
        {
        VEDCOUNT = "";

        while ('0' <= s._chr <= '9')
          {
          VEDCOUNT += char (s._chr);
          s._chr = Input.getch (;disable_langchange);
          }

        try
          VEDCOUNT = integer (VEDCOUNT);
        catch SyntaxError:
          {
          ismsg = 1;
          Smg.send_msg_dr ("count: too many digits >= " +
            string (256 * 256 * 256 * 128), 1, s.ptr[0], s.ptr[1]);
          continue;
          }
        }

      s.vedloopcallback ();

      if (ismsg)
        {
        Smg.send_msg_dr (" ", 0, s.ptr[0], s.ptr[1]);
        ismsg = 0;
        }

      if (':' == s._chr && (VED_RLINE || 0 == VED_ISONLYPAGER))
        {
        topline (" -- command --");
        rl = Ved.get_cur_rline ();
        Rline.set (rl);
        Rline.readline (rl;
          ved = s, draw = (@__get_reference ("SCRATCH")) == s._abspath ? 0 : 1);

        if ('!' == Ved.get_cur_rline ().argv[0][0] &&
           (@__get_reference ("SCRATCH")) == s._abspath)
          {
          (@__get_reference ("draw")) (s);
          continue;
          }

        topline (" -- pager --");
        s = Ved.get_cur_buf ();
        Smg.setrcdr (s.ptr[0], s.ptr[1]);
        }

      if ('q' == s._chr && VED_ISONLYPAGER)
        return 1;
      }

    0;
  end

  def _vedloop_ (s) proc
    if (_loop_ (s))
      return;
  end

  def autoindent (s, indent, line) proc
    % lookup for a (not private) type_autoindent
    variable f = __get_reference (s._type + "_autoindent");
    % call it (if exists) and calc the value
    if (NULL == f)
    % else calculate the value as:
      @indent =  s._indent + (s._autoindent ? s._shiftwidth : 0);
    else
      @indent = (@f) (s, line);
  end

  def lexicalhl (s, lines, vlines) proc
  end

  def _on_lang_change_ (mode, ptr) public proc
    topline (" -- " + mode + " --");
    Smg.setrcdr (ptr[0], ptr[1]);
  end

  def __vlinlen (s, r) proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    strlen (s.lins[r]) - s._indent;
  end

  def __vline (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    s.lins[r];
  end

  def __vlnr (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    s.lnrs[r];
  end

  def __vtail (s) proc
    variable
      lnr = __vlnr (s, '.') + 1,
      line = __vline (s, '.');

    sprintf (
      "[%s] (row:%d col:%d lnr:%d/%d %.0f%% strlen:%d chr:%d) undo %d/%d",
      path_basename (s._fname), s.ptr[0], s.ptr[1] - s._indent + 1, lnr,
      s._len + 1, (100.0 / s._len) * (lnr - 1), __vlinlen (s, '.'),
      qualifier ("chr", String.decode (substr (line, s._index + 1, 1))[0]),
      s._undolevel, length (s.undo));
  end

  def __vdraw_tail (s) proc
    if (s._is_wrapped_line)
      Smg.hlregion (1, s.ptr[0], COLUMNS - 2, 1, 2);

    Smg.atrcaddnstrdr (__vtail (s;;__qualifiers ()), VED_INFOCLRFG, s.rows[-1], 0, s.ptr[0], s.ptr[1],
      COLUMNS);
  end

  def _draw_ (s) proc
    if (-1 == s._len) % this shouldn't occur
      {
      Smg.send_msg ("_draw_ (), caught -1 == s._len condition" + s._fname, 1);
      s.lins = [__get_null_str (s._indent)];
      s.lnrs = [0];
      s._ii = 0;

      Smg.aratrcaddnstrdr ([repeat (" ", COLUMNS), __vtail (s)], [0, VED_INFOCLRFG],
        [s.rows[0], s.rows[-1]], [0, 0], s.rows[0], 0, COLUMNS);

      return;
      }

    s.lnrs = Integer_Type[0];
    s.lins = String_Type[0];

    variable
      i = s.rows[0],
      ar = String_Type[0];

    s._ii = s._i;

    while (s._i <= s._len && i <= s.rows[-2])
      {
      s.lnrs = [s.lnrs, s._i];
      s.lins = [s.lins, s.lines[s._i]];
      s._i++;
      i++;
      }

    s.vlins = [s.rows[0]:s.rows[0] + length (s.lins) - 1];

    s._i = s._i - (i) + s.rows[0];

    if (-1 == s._i)
      s._i = 0;

    if (s.ptr[0] >= i)
      s.ptr[0] = i - 1;

    ar = array_map (String_Type, &substr, s.lins, 1, s._maxlen);

    variable indices = [0:length (ar) - 1];
    variable clrs = @s.clrs;
    variable arlen = length (ar);
    variable rowslen = length (s.rows);

    if (arlen < rowslen - 1)
      {
      ifnot (s._type == "ashell")
        clrs[[arlen:length (clrs) -2]] = 5;
      variable t = String_Type[rowslen - arlen - 1];
      t[*] = s._type == "ashell" ? " " : "~";
      ar = [ar, t];
      }

    ar = [ar, __vtail (s;;__qualifiers ())];

    Smg.set_img (s.rows, ar, clrs, s.cols);

    Smg.aratrcaddnstr (ar, clrs, s.rows, s.cols, COLUMNS);

    s.lexicalhl (ar[indices], s.vlins);

    (@[Smg.setrcdr, Smg.setrc][qualifier_exists ("dont_draw")]) (Smg, s.ptr[0], s.ptr[1]);
  end

  include self from Ved as Ved

  require topline from wind

  def __vfpart_of_word (s, line, col, start) proc
    ifnot (strlen (line))
      return "";

    variable origcol = col;

    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent &&
        any (WCHARS == substr (line, col + 1, 1)));

      @start = col + 1;
      }

    substr (line, @start + 1, origcol - @start + 1);
  end

  def __vfind_word (s, line, col, start, end) public proc
    if (0 == strlen (line) || ' ' == line[col] ||
        0 == any (WCHARS == char (line[col])))
      return "";

    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent &&
        any (WCHARS == substr (line, col + 1, 1)));

      @start = col + 1;
      }

    variable len = strlen (line);

    while (col++, col < len && any (WCHARS == substr (line, col + 1, 1)));

    @end = col - 1;

    substr (line, @start + 1, @end - @start + 1);
  end

  def __vfind_Word (s, line, col, start, end) proc
    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent && 0 == isblank (substr (line, col + 1, 1)));

      @start = col + 1;
      }

    variable len = strlen (line);

    while (col++, col < len && 0 == isblank (substr (line, col + 1, 1)));

    @end = col - 1;

    substr (line, @start + 1, @end - @start + 1);
  end

  def __get_dec (chr, dir) proc
    any ([['0':'9'], '.'] == chr);
  end

  def __get_hex (chr, dir) proc
    any (chr == ("lhs" == dir ? ['0'] : [['0':'9'], ['a':'f'], ['A':'F'], 'x']));
  end

  def __vfind_nr (indent, line, col, start, end, ishex, isoct, isbin) proc
    ifnot (any ([['0':'9'], '-', '.', 'x'] == line[col]))
      return "";

    variable mbishex = 0;
    variable getfunc = [&__get_dec, &__get_hex];

    @ishex = 'x' == line[col];
    getfunc = getfunc[@ishex];

    ifnot (col - indent)
      @start = indent;
    else
      {
      ifnot (line[col] == '-')
        while (col--, col >= indent && (@getfunc) (line[col], "lhs"));

      @start = col + 1;

      if (col)
        if (line[col] == '-')
          @start--;
        else if (line[col] == 'x') % maybe is hex
          mbishex = 1; % when at least one digit found, and 'x' is not the char 
      }                % where the matching stopped. the string under the cursor
                       % can form a valid hex number
    variable len = strlen (line);

    while (col++, col < len && (@getfunc) (line[col], "rhs"));

    @end = col - 1;

    variable nr = substr (line, @start + 1, @end - @start + 1);

    if (nr == "-" || nr == "." || nr[0] == '.' || 0 == strlen (nr))
      return "";

    if (1 == strlen (nr))
      if ('0' == nr[0])
        if (col < len)
          ifnot (@ishex)
            if ('x' == line[col])
              mbishex = 1;

    % hex incr/decr is done when cursor is on an 'x'
    if (mbishex)  % for now and for both conditions and for safety, refuse
      return "";  % to modify the string, if an 'x' is found on the string

    len = strlen (nr);
    col = 0;

    ifnot (len mod 4)
      while (col++, col < len && (@isbin = any (['0','1'] == nr[col]), @isbin));

    col = 0;

    if (1 < len && 0 == @isbin)
      if ('0' == nr[0])
        while (col++, col < len && (@isoct = any (['0':'7'] == nr[col]), @isoct));

    if (nr[-1] == '.')
      if (len > 1)
        {
        nr = substr (nr, 1, len - 1);
        @end--;
        }
      else
        return "";

    if (@ishex || @isoct || @isbin)
      try
        return string (integer (sprintf ("%s%s", @isbin ? "0b" : "", nr)));
      catch SyntaxError:
        return "";

    nr;
  end

  def on_wind_change (w) public proc
  end

  def wind_change (to) proc
    variable winds = assoc_get_keys (VED_WIND);
    winds = winds[array_sort (winds)];

    variable w;
    variable i;

    if (Integer_Type == typeof (to))
      if (length (winds) - 1 < to)
        return;
      else
        w = winds[to];
    else
      ifnot (any ([",", "."] == to))
        return;
      else
        if (to == ",")
          w = winds[wherefirst (winds == VED_CUR_WIND) - 1];
        else
          {
          i = wherefirst (winds == VED_CUR_WIND);
          i = i == length (winds) - 1 ? 0 : i + 1;
          w = winds[i];
          }

    if (w == VED_CUR_WIND)
      return;

    VED_PREV_WIND = VED_CUR_WIND;
    VED_CUR_WIND = w;

    w = VED_WIND[w];

    on_wind_change (w);

    Ved.draw_wind ();
  end

  def next_wind (s) proc
    wind_change (".");
  end

  def on_wind_new (w) public proc
    (@__get_reference ("__initrline"));
  end

  def wind_init (name, frames) public proc
    if (any (name == assoc_get_keys (VED_WIND)) && 0 == qualifier_exists ("force"))
      return;

    variable setframesize = __get_qualifier_as (Ref_Type, "framesize_fun",
      qualifier ("framesize_fun"), This.framesize_fun);

    if (NULL == setframesize)
      setframesize = &framesize;

    VED_WIND[name] = @Wind_Type;
    VED_WIND[name].name = name;
    VED_WIND[name].frames = frames > This.max_frames
      ? This.max_frames
      : frames < 1
        ? 1
        : frames;
    VED_WIND[name].frame_names = String_Type[VED_WIND[name].frames];
    VED_WIND[name].frame_rows = (@setframesize) (VED_WIND[name].frames);
    VED_WIND[name].cur_frame = 0;
    VED_WIND[name].buffers = Assoc_Type[Ftype_Type];
    VED_WIND[name].bufnames = String_Type[0];

    if (qualifier_exists ("on_wind_new"))
      on_wind_new (VED_WIND[name]);
  end

  def new_wind () proc
    variable name = _NARGS ? () : NULL;

    variable i;
    variable winds = assoc_get_keys (VED_WIND);
    variable frames = __get_qualifier_as (Integer_Type, "frames",
      qualifier ("frames"), This.frames);

    if (NULL == frames)
      frames = 1;

    if (any (name == winds))
      return;

    if (NULL == name)
      _for i ('a', 'z')
        {
        name = char (i);
        ifnot (any (name == winds))
          break;

        if ('z' == i)
          return;
        }

    ifnot (qualifier_exists ("in_bg"))
      {
      ifnot (NULL == VED_CUR_WIND)
        VED_PREV_WIND = VED_CUR_WIND;
      VED_CUR_WIND = name;
      }

    wind_init (name, frames;;__qualifiers ());

    if (qualifier_exists ("draw_wind"))
      Ved.draw_wind ();
  end

  def bufdelete (s, bufname, force) public proc
    if (any (bufname == UNDELETABLE))
      return;

    variable w = Ved.get_cur_wind ();

    ifnot (any (bufname == w.bufnames))
      return;

    if (s._flags & VED_MODIFIED && force)
      {
      variable bts = 0;
      variable retval = __vwritetofile (bufname, s.lines, s._indent, &bts);
      ifnot (0 == retval)
        {
        Smg.send_msg_dr (errno_string (retval), 1, NULL, NULL);
        return;
        }
      }

    variable isatframe = wherefirst (w.frame_names == bufname);
    variable iscur = Ved.get_cur_bufname () == bufname;

    assoc_delete_key (w.buffers, bufname);

    variable index = wherefirst (bufname == w.bufnames);

    w.bufnames[index] = NULL;
    w.bufnames = w.bufnames[wherenot (_isnull (w.bufnames))];

    variable winds = assoc_get_keys (VED_WIND);

    ifnot (length (w.bufnames))
      if (1 == length (winds))
        exit_me (0);
      else
        {
        assoc_delete_key (VED_WIND, VED_CUR_WIND);
        winds = assoc_get_keys (VED_WIND);
        VED_CUR_WIND = winds[0];
        w = Ved.get_cur_wind ();
        s = Ved.get_cur_buf ();
        Ved.setbuf (s._abspath);
        Ved.draw_wind ();
        return;
        }

    ifnot (NULL == isatframe)
      if (1 < w.frames)
        Ved.del_frame (isatframe);

    if (iscur)
      {
      index = index ? index - 1 : length (w.bufnames) - 1;

      Ved.setbuf (w.bufnames[index]);

      s = Ved.get_cur_buf ();
      s.draw ();
      }
  end

  include reg  from Ved as Ved
  include mark from Ved as Ved

  def preloop (s)
    markbacktick (s);
  end

  def __err_handler__ (t, _s_) proc
    (@__get_reference ("__vmessages"));
    variable s = Ved.get_cur_buf ();
    Ved.draw_wind ();
    s.vedloop ();
  end

  beg
    This.err_handler = &__err_handler__;
  end

  def __hl_groups (lines, vlines, colors, regexps) public proc
    variable
      i,
      ii,
      col,
      subs,
      match,
      color,
      regexp,
      line,
      iscomment = 0,
      context;

    _for i (0, length (lines) - 1)
      {
      line = lines[i];
      if (0 == strlen (line) || "\000" == line)
        continue;

      iscomment = '%' == strtrim_beg (line)[0];

      _for ii (0, length (regexps) - 1)
        {
        color = colors[ii];
        regexp = regexps[ii];
        col = 0;

        if (ii && iscomment)
          break;

        while (subs = pcre_exec (regexp, line, col), subs > 1)
          {
          match = pcre_nth_match (regexp, 1);
          col = match[0];
          context = match[1] - col;
          Smg.hlregion (color, vlines[i], col, 1, context);
          col += context;
          }

        ifnot (ii)
          if (col)
            line = substr (line, 1, match[0] + 1); % + 1 is to avoid the error pattern
                                                   % to match it as eol
        }
      }
  end

  def __vreread (s) public proc
    s.lines = Ved.getlines (s._fname, s._indent, s.st_);

    s._len = length (s.lines) - 1;

    ifnot (s._len)
      {
      s._ii = 0;
      s.ptr[0] = s.rows[0];
      }
    else if (s._ii < s._len)
      {
      s._i = s._ii;
      while (s.ptr[0] - s.rows[0] + s._ii > s._len)
        s.ptr[0]--;
      }
    else
      {
      while (s._ii > s._len)
        s._ii--;

      s.ptr[0] = s.rows[0];
      }

    s.ptr[1] = 0;

    s._i = s._ii;

    s.draw ();
  end

  def _change_frame_ (s) public proc
    Ved.change_frame (;;__qualifiers);
    s = Ved.get_cur_buf ();
  end

  def _new_frame_ (s) public proc
    Ved.new_frame (VED_DIR + "/" + string (_time) + ".noname";_autochdir = 0);
    s = Ved.get_cur_buf ();
  end

  def _del_frame_ (s) proc
    Ved.del_frame ();
    s = Ved.get_cur_buf ();
  end

  def _del_wind_ (s) proc
    Ved.del_wind (VED_CUR_WIND);
    s = Ved.get_cur_buf ();
  end

  def on_wind_change (w) proc
    topline (" -- ved --");
    Ved.setbuf (w.frame_names[w.cur_frame]);
  end

  def on_wind_new (w) public proc
    variable fn = VED_DIR + "/" + string (_time) + ".noname";
    variable s = Ved.init_ftype ("txt");

    SPECIAL = [SPECIAL, fn];

    variable func = __get_reference ("txt_settype");
    (@func) (s, fn, w.frame_rows[0], NULL;_autochdir = 0);

    Ved.setbuf (fn);
    (@__get_reference ("__initrline"));
    topline (" -- ved --");
    Ved.draw_wind ();
  end

  def _new_wind_ (s) public proc
    new_wind (;on_wind_new);
    s = Ved.get_cur_buf ();
  end

  def _goto_wind_ (s, chr) proc
    if (any (['0':'9'] == chr))
      chr = int (chr - '0');
    else
      chr = char (chr);

    wind_change (chr);
    s = Ved.get_cur_buf ();
  end

  def handle_w (s) public proc
    variable chr = Input.getch ();

    if (any (['w', 's', Input->UP, Input->CTRL_w, Input->DOWN, 'd', 'k', 'n', ',', '.', ['0':'9']] == chr))
      {
      if (any (['w', Input->CTRL_w, Input->DOWN] == chr))
        {
        _change_frame_ (s;dir = "next");
        return;
        }

      if (any ([Input->UP] == chr))
        {
        _change_frame_ (s;dir = "prev");
        return;
        }

      if ('s' == chr)
        {
        _new_frame_ (s);
        return;
        }

      if ('d' == chr)
        {
        _del_frame_ (s);
        return;
        }

      if ('k' == chr)
        {
        _del_wind_ (s);
        return;
        }

      if ('n' == chr)
        {
        _new_wind_ (s);
        return;
        }

      if (any ([['0':'9'], ',', '.'] == chr))
        {
        _goto_wind_ (s, chr);
        return;
        }
      }
  end

  def __pg_on_carriage_return (s) public proc
  end

  def pg_write_on_esc (s) proc
    Ved.writefile (s, NULL, s.ptr, NULL, NULL);
    Smg.send_msg_dr ("", 14, NULL, NULL);
    sleep (0.001);
    Smg.setrcdr (s.ptr[0], s.ptr[1]);
  end

  def pg_gotomark (s) proc
    variable m = mark_get ();

    if (NULL == m)
      return;

    if (m._i > s._len)
      return;

    markbacktick (s);

    s._i = m._i;
    s.ptr = m.ptr;
    s._index = m._index;
    s._findex = m._findex;

    s.draw ();

    variable len = __vlinlen (s, '.');
    if (s.ptr[1] > len)
      { % do: catch the if _is_wrapped_line condition
      if (len > s._maxlen)
        s.ptr[1] = s._maxlen; % probably wrong (unless _index changes too
      else
        s.ptr[1] = s._indent + len;

      s._index = s.ptr[1];
      s._findex = s._indent;
      Smg.setrcdr (s.ptr[0], s.ptr[1]);
      }
  end

  def _set_nr_ (s, incrordecr) proc
    variable
      count = qualifier ("count", 1),
      end,
      start,
      nr,
      col = s._index,
      i = __vlnr (s, '.'),
      line = __vline (s, '.');

    variable ishex = 0;
    variable isoct = 0;
    variable isbin = 0;

    nr = __vfind_nr (s._indent, line, col, &start, &end, &ishex, &isoct, &isbin);
    ifnot (strlen (nr))
      {
      nr = String.decode (line)[col];

      if ("+" == incrordecr)
        nr += count;
      else
        nr -= count;

      if (any (nr ==  [[0:31], ['~' + 1:160]]))
        return;

      line = sprintf ("%s%c%s", substr (line, 1, col), nr, substr (line, col + 2, -1));

      s.lins[s.ptr[0] - s.rows[0]] = line;
      s.lines[i] = line;
      set_modified (s);

      s.st_.st_size = Array.getsize (s.lines);

      waddline (s, line, 0, s.ptr[0]);

      __vdraw_tail (s);
      return;
      }

    variable isdbl = _slang_guess_type (nr) == Double_Type;
    variable convf = [&atoi, &atof];
    convf = convf[isdbl];

    if ("+" == incrordecr)
      nr = (@convf) (nr) + count;
    else
      nr = (@convf) (nr) - count;

    variable format = sprintf ("%s%%%s",
      ishex ? "0x0" : isoct ? "0" : "",
      ishex ? "x" : isoct ? "o" : isbin ? "B" : isdbl ? ".3f" : "d");

    nr = sprintf (format, nr);

    if (isbin)
      while (strlen (nr) mod 4)
        nr = "0" + nr;

    line = sprintf ("%s%s%s", substr (line, 1, start), nr, substr (line, end + 2, -1));

    s.lins[s.ptr[0] - s.rows[0]] = line;
    s.lines[i] = line;
    s.ptr[1] = start;
    s._index = start;

    set_modified (s);

    s.st_.st_size = Array.getsize (s.lines);

    waddline (s, line, 0, s.ptr[0]);

    __vdraw_tail (s);
  end

  def _incr_nr_ (s) proc
    _set_nr_ (s, "+";count = VEDCOUNT == -1 ? 1 : VEDCOUNT);
  end

  def _decr_nr_ (s) proc
    _set_nr_ (s, "-";count = VEDCOUNT == -1 ? 1 : VEDCOUNT);
  end

  def undo (s) proc
    Vundo.undo (s);
  end

  def redo (s) proc
    Vundo.redo (s);
  end

  def v_lastvi () proc
  end

  include pager from Ved as Ved
  include ed     from Ved as Ved
  include search from Ved as Ved
  include insert from Ved as Ved
  include visual from Ved as Ved

  def _register_ (s) proc
    variable reg = Input.getch ();
    ifnot (any (_regs_ () == reg))
      return;

    reg = char (reg);

    variable chr = Input.getch ();
    ifnot (any (['D', 'c', 'd', 'Y', 'p', 'P', 'x', 'X', Input->rmap.delete]
      == chr))
      return;

    if (any (['x', 'X', Input->rmap.delete] == chr))
      ed_del_chr (s;reg = reg, chr = chr);
    else if ('Y' == chr)
      pg_Yank (s;reg = reg);
    else if ('d' == chr)
      ed_del (s;reg = reg);
    else if ('c' == chr)
      ed_change (s;reg = reg);
    else if ('D' == chr)
      ed_del_to_end (s;reg = reg);
    else if ('P' == chr)
      ed_Put (s;reg = reg);
    else
      ed_put (s;reg = reg);
  end


  def _askonsubst_ (s, fn, lnr, fpart, context, lpart, replace) proc
    variable cmp_lnrs = Integer_Type[0];
    variable ar =
      ["@" + fn + " linenr: " + string (lnr+1),
       "replace?",
       repeat ("_", COLUMNS),
       sprintf ("%s%s%s", fpart, context, lpart),
       repeat ("_", COLUMNS),
       "with?",
       repeat ("_", COLUMNS),
       sprintf ("%s%s%s", fpart, replace, lpart),
       repeat ("_", COLUMNS),
       "y[es]/n[o]/q[uit]/a[ll]/c[ansel]"];

    variable hl_reg = Array_Type[2];
    hl_reg[0] = [5, PROMPTROW - 8, strlen (fpart), 1, strlen (context)];
    hl_reg[1] = [2, PROMPTROW - 4, strlen (fpart), 1, strlen (replace)];

    variable char_ar =  ['y', 'n', 'q', 'a', 'c'];
    Smg.askprintstr (ar, char_ar, &cmp_lnrs;hl_region = hl_reg);
  end

  def __substitute () public proc
    variable global = 0, ask = 1, pat = NULL, sub = NULL, ind, range = NULL;
    variable args = __pop_list (_NARGS);
    variable buf = Ved.get_cur_buf ();
    variable lnrs = [0:buf._len];

    args = list_to_array (args, String_Type);

    ind = Opt.is_arg ("--pat=", args);
    ifnot (NULL == ind)
      pat = substr (args[ind], strlen ("--pat=") + 1, -1);

    ind = Opt.is_arg ("--sub=", args);
    ifnot (NULL == ind)
      sub = substr (args[ind], strlen ("--sub=") + 1, -1);

    if (NULL == pat || NULL == sub)
      {
      Smg.send_msg_dr ("--pat= and --sub= are required", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    if (0 == strlen (pat) || 0 == strlen (sub))
      {
      Smg.send_msg_dr ("--pat= and --sub= are required", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    ind = Opt.is_arg ("--global", args);
    ifnot (NULL == ind)
      global = 1;

    ind = Opt.is_arg ("--dont-ask-when-subst", args);
    ifnot (NULL == ind)
      ask = 0;

    ind = Opt.is_arg ("--range=", args);
    ifnot (NULL == ind)
      {
      lnrs = Ved.parse_arg_range (buf, args[ind], lnrs);
      if (NULL == lnrs)
        return;
      }

    variable s = Subst.new (pat, sub;
      fname = buf._abspath, global = global, askwhensubst = ask, askonsubst = &_askonsubst_);

    if (NULL == s)
      {
      variable err = ();
      IO.tostderr (err);
      return;
      }

    variable retval = Subst.exec (s, buf.lines[lnrs]);

    ifnot (retval)
      {
      variable ar= ();
      ifnot (length (ar) == length (lnrs))
        {
        ifnot (lnrs[0])
          ifnot (lnrs[-1] == buf._len)
            buf.lines = [ar, buf.lines[[lnrs[-1] + 1:]]];
          else
            buf.lines = ar;
        else
          ifnot (lnrs[-1] == buf._len)
            buf.lines = [buf.lines[[:lnrs[0] - 1]], ar, buf.lines[[lnrs[-1] + 1:]]];
          else
            buf.lines = [buf.lines[[:lnrs[0] - 1]], ar];

        buf._len = length (buf.lines) - 1;
        }
      else
        buf.lines[lnrs] = ar;

      buf.st_.st_size = Array.getsize (buf.lines);
      set_modified (buf);
      buf.draw ();
      }
  end

  def PROJECT_VED (argv) public proc
    ifnot (length (argv) - 1)
      return;

    variable pj;
    variable fn;
    variable args = argv[[1:]];

    variable ind = Opt.is_arg ("--from-file=", args);
    ifnot (NULL == ind)
      {
      fn = strchop (args[ind], '=', 0);
      if (1 == length (fn))
        return;

      fn = fn[1];

      if (-1 == access (fn, F_OK|R_OK))
        return;

      variable ar = File.readlines (fn);

      pj = strtok (ar[0]);
      }
    else
      pj = args;

    if (length (pj) + length (assoc_get_keys (VED_WIND)) > 10)
      return;

    variable wc = VED_CUR_WIND, i, w = NULL, j, found,
      nwns,owns = assoc_get_keys (VED_WIND);

    _for i (0, length (pj) - 1)
      {
      fn = pj[i];
      if (access (fn, F_OK|R_OK))
        continue;

      new_wind (;on_wind_new);

      nwns = assoc_get_keys (VED_WIND);

      if (length (nwns) == length (owns))
        continue;

      _for j (0, length (nwns) - 1)
        if (any (nwns[j] == owns))
          continue;
        else
          {
          w = nwns[j];
          break;
          }

      owns = @nwns;
      variable cw = Ved.get_cur_wind ();
      variable ft = qualifier ("ftype");
      if (NULL == ft)
        ft = Ved.get_ftype (fn);
      variable s = Ved.init_ftype (ft);
      variable func = __get_reference (sprintf ("%s_settype", ft));
      (@func) (s, fn, cw.frame_rows[Ved.get_cur_frame ()], NULL);

      Ved.setbuf (s._abspath);
      }

    if (NULL == w)
      return;

    VED_PREV_WIND = wc;
    VED_CUR_WIND = w;

    Ved.draw_wind ();
  end

  beg
    VED_PAGER[string (Input->F3)]      = &next_wind;
    VED_PAGER[string (',')]            = &handle_comma;
    VED_PAGER[string ('"')]            = &_register_;
    VED_PAGER[string (Input->CTRL_a)]  = &_incr_nr_;
    VED_PAGER[string (Input->CTRL_x)]  = &_decr_nr_;
    VED_PAGER[string (Input->CTRL_l)]  = &__vreread;
    VED_PAGER[string (Input->UP)]      = &pg_up;
    VED_PAGER[string (Input->DOWN)]    = &pg_down;
    VED_PAGER[string (Input->ESC_esc)] = &pg_write_on_esc;
    VED_PAGER[string (Input->HOME)]    = &pg_bof;
    VED_PAGER[string (Input->NPAGE)]   = &pg_page_down;
    VED_PAGER[string (Input->CTRL_f)]  = &pg_page_down;
    VED_PAGER[string (Input->CTRL_b)]  = &pg_page_up;
    VED_PAGER[string (Input->PPAGE)]   = &pg_page_up;
    VED_PAGER[string (Input->RIGHT)]   = &pg_right;
    VED_PAGER[string (Input->LEFT)]    = &pg_left;
    VED_PAGER[string (Input->END)]     = &pg_eol;
    VED_PAGER[string (Input->CTRL_w)]  = &handle_w;
    VED_PAGER[string (Input->CTRL_r)]  = &redo;
    VED_PAGER[string (Input->BSLASH)]  = &search;
    VED_PAGER[string (Input->QMARK)]   = &search;
    VED_PAGER[string (Input->CTRL_v)]  = &vis_mode;
    VED_PAGER[string (033)]            = &pag_completion;
    VED_PAGER[string ('\r')]           = &__pg_on_carriage_return;
    VED_PAGER[string ('m')]            = &mark;
    VED_PAGER[string ('`')]            = &pg_gotomark;
    VED_PAGER[string ('Y')]            = &pg_Yank;
    VED_PAGER[string ('j')]            = &pg_down;
    VED_PAGER[string ('k')]            = &pg_up;
    VED_PAGER[string ('G')]            = &pg_eof;
    VED_PAGER[string ('g')]            = &pg_g;
    VED_PAGER[string (' ')]            = &pg_page_down;
    VED_PAGER[string ('e')]            = &pg_end_word;
    VED_PAGER[string ('l')]            = &pg_right;
    VED_PAGER[string ('h')]            = &pg_left;
    VED_PAGER[string ('-')]            = &pg_eos;
    VED_PAGER[string ('$')]            = &pg_eol;
    VED_PAGER[string ('^')]            = &pg_bolnblnk;
    VED_PAGER[string ('0')]            = &pg_bol;
    VED_PAGER[string ('u')]            = &undo;
    VED_PAGER[string ('#')]            = &s_search_word_;
    VED_PAGER[string ('*')]            = &s_search_word_;
    VED_PAGER[string ('n')]            = &s_backslash_reg_;
    VED_PAGER[string ('N')]            = &s_backslash_reg_;
    VED_PAGER[string ('v')]            = &vis_mode;
    VED_PAGER[string ('V')]            = &vis_mode;
    VED_PAGER[string ('~')]            = &ed_toggle_case;
    VED_PAGER[string ('P')]            = &ed_Put;
    VED_PAGER[string ('p')]            = &ed_put;
    VED_PAGER[string ('o')]            = &ed_newline;
    VED_PAGER[string ('O')]            = &ed_newline;
    VED_PAGER[string ('c')]            = &ed_change;
    VED_PAGER[string ('d')]            = &ed_del;
    VED_PAGER[string ('D')]            = &ed_del_to_end;
    VED_PAGER[string ('C')]            = &ed_editline;
    VED_PAGER[string ('i')]            = &ed_editline;
    VED_PAGER[string ('a')]            = &ed_editline;
    VED_PAGER[string ('A')]            = &ed_editline;
    VED_PAGER[string ('r')]            = &ed_chang_chr;
    VED_PAGER[string ('J')]            = &ed_join_line;
    VED_PAGER[string ('>')]            = &ed_indent_out;
    VED_PAGER[string ('<')]            = &ed_indent_in;
    VED_PAGER[string ('x')]            = &ed_del_chr;
    VED_PAGER[string ('X')]            = &ed_del_chr;
    VED_PAGER[string (Input->F12)]     = &paste_xsel;
    VED_PAGER[string (Input->rmap.delete[0])]    = &ed_del_chr;
    VED_PAGER[string (Input->rmap.backspace[0])] = &ed_del_trailws;
    VED_PAGER[string (Input->rmap.backspace[1])] = &ed_del_trailws;
    VED_PAGER[string (Input->rmap.backspace[2])] = &ed_del_trailws;

    ifnot (NULL == Env->DISPLAY)
      ifnot (NULL == Env->XAUTHORITY)
        ifnot (NULL == Sys->XCLIP_BIN)
          Load.file (Env->STD_LIB_PATH + "/X/seltoX", NULL);
  end

  def msg_handler (s, msg) proc
    variable b = Ved.get_cur_buf ();
    Smg.send_msg_dr (msg, 1, b.ptr[0], b.ptr[1]);
  end

  load Vundo from Ved

  beg
    new_wind ();
  end
end
