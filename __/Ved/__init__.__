class Ved
  typedef Ftype
    _i,_ii,_len,_chr,_type,_fname,_abspath,_fd,_flags,_maxlen,_indent,
    _linlen,_avail_rows,_findex,_index,_shiftwidth,_expandtab,_undolevel,
    _autoindent, _dir, _autochdir,
    undo, undoset, ptr, rows, cols, clrs, lins, lnrs, vlins, lines,
    st_, comment_str,
    vedloop, vedloopcallback,
    ved, set,
    draw, lexicalhl, autoindent, pairs,
    opt_show_tilda, opt_show_status_line,
    __NOR__,
    __VAR__,
  end

  typedef Insert
    chr,
    lnr,
    prev_l,
    next_l,
    modified,
  end

  typedef Pos
    _i,
    _index,
    _findex,
    ptr,
  end

  typedef Wind
    cur_frame,
    frame_rows,
    frame_names,
    frames,
    buffers,
    bufnames,
    rline,
    name,
    dir,
    prev_buf_ind,
  end

  let VED_DIR = Env->TMP_PATH + "/ved/" + string (Env->PID);
  let EL_MAP  = [902, [904:906], 908, [910:929], [931:937], [945:974]];
  let EN_MAP  = [['a':'z'], ['A':'Z']];
  let MAPS    = [EL_MAP, EN_MAP];
  let WCHARS  = array_map (String_Type, &char, [['0':'9'], EN_MAP, EL_MAP, '_']);
  let DEFINED_UPPER_CASE = ['+', ',', '}', ')', ':', '>'];
  let DEFINED_LOWER_CASE = ['-', '.', '{', '(', ';', '<'];

  var public MARKS        = Assoc_Type[Struct_Type];
  var public VED_WIND     = Assoc_Type[Wind_Type];
  var public FTYPES       = Assoc_Type[Integer_Type];
  var public REG          = Assoc_Type[String_Type];
  var public VED_CUR_WIND = NULL;
  var public UNDELETABLE  = String_Type[0];
  var public SPECIAL      = String_Type[0];
  var public VED_ROWS     = [1:LINES - 3];
  var public VED_MODIFIED       = 0x01;
  var public VED_ONDISKMODIFIED = 0x02;
  var public VED_RDONLY         = 0x04;
  var public VED_ISONLYPAGER    = 0;
  var public VED_RLINE          = 1;
  var public SEARCH_HISTFILE    = Env->USER_DATA_PATH + "/.__" + Env->USER + "_ved_search_history";
  var public SEARCH_HISTINDEX   = NULL;
  var public SEARCH_HISTORY     = {};
  var public VED_OPTS = struct
    {
    del_frame = 1,
    new_frame = 1,
    new_wind = 1,
    };

  var VED_INFOCLRFG = Smg->COLOR.infofg;
  var VED_INFOCLRBG = Smg->COLOR.infobg;
  var VED_PROMPTCLR = Smg->COLOR.prompt;
  var VED_PREV_WIND = NULL;

  def __invalid__ () proc
    pop ();
  end

  var public VED_PAGER = Assoc_Type[Ref_Type, &__invalid__];
  var public VEDCOUNT;

  def build_ftype_table () proc
    variable i, ii, ft;
    variable nss = [Env->USER_DATA_PATH, Env->STD_DATA_PATH];

    _for i (0, length (nss) - 1)
      {
      ft = listdir (nss[i] + "/ftypes");
      if (NULL == ft)
        continue;

      _for ii (0, length (ft) - 1)
        if (Dir.isdirectory (nss[i] + "/ftypes/" + ft[ii]))
          FTYPES[ft[ii]] = 0;
      }
  end

  beg
    Sys.let ("XCLIP_BIN", Sys.which ("xclip"));
    build_ftype_table ();

    if (-1 == Dir.make_parents (VED_DIR, File->PERM["PRIVATE"]))
      throw ClassError, "Ved::ATINIT::" + VED_DIR + ": cannot make directory, "
        + errno_string (errno);
  end

  def getXsel () public proc
    "";
  end

  def seltoX (sel) public proc
  end

  def topline () public proc
  end

  def toplinedr () public proc
  end

  def __console () public proc
  end

  subclass Reg from Ved

  def toogle_infoclrbg ()
    if (VED_INFOCLRBG == Smg->NOCOLOR)
      VED_INFOCLRBG = Smg->COLOR.infobg;
    else
      VED_INFOCLRBG = Smg->NOCOLOR;
  end

  def toogle_infoclrfg ()
    if (VED_INFOCLRFG == Smg->NOCOLOR)
      VED_INFOCLRFG = Smg->COLOR.infofg;
    else
      VED_INFOCLRFG = Smg->NOCOLOR;
  end

  def __define_case__ (chr) proc
    ifnot (any (@chr == [DEFINED_LOWER_CASE, DEFINED_UPPER_CASE]))
      return 0;

    variable low = 1;
    variable ind = wherefirst_eq (DEFINED_LOWER_CASE, @chr);
    if (NULL == ind)
      {
      ind = wherefirst_eq (DEFINED_UPPER_CASE, @chr);
      low = 0;
      }

    @chr = low ? DEFINED_UPPER_CASE[ind] : DEFINED_LOWER_CASE[ind];

    1;
  end

  def __indent_In__ (s, line, i_) proc
    ifnot (strlen (line) - s._indent)
      return NULL;

    ifnot (isblank (line[s._indent]))
      return NULL;

    while (isblank (line[@i_]) && @i_ < s._shiftwidth + s._indent)
      @i_++;

    substr (line, @i_ + 1 - s._indent, -1);
  end

%%%%%%% __private __vinterface
  def __vdebug (s, msg) public proc
    Smg.send_msg_dr (msg, 1, s.ptr[0], s.ptr[1]);
    if (qualifier_exists ("hold"))
      () = Input.getch ();
  end

  def __vset_col__ (s, linlen, dir) proc
    if ('+' == dir)
      if (s.ptr[1] + 1 < linlen - s._indent)
        ifnot (s.ptr[1] + 1 == s._indent + s._linlen) % -> cells/context
          s.ptr[1]++;
  end

  def __vset_col_at_end__ (s, linlen) proc
    if (linlen <= s._linlen)
      s.ptr[1] = s._indent + linlen;
    else
      s.ptr[1] = s._indent + s._maxlen; % handle case when maxlen + indent > virtual cols
  end

  def __vis_wrapped__ (s, linlen, index, findex) proc
    variable vlen = s._maxlen - s._indent;
    if (linlen <= vlen)
      return 0;

    ifnot (NULL == index)
      if (index >= vlen)
        return 1;

    ifnot (NULL == findex)
      if (findex - s._indent)
        return 1;

    0;
  end

%%%% end

  % -1 = abort, 1 = need refresh, 0 = nothing
  def __left (s, is_wrap) proc
    ifnot (s.ptr[1] - s._indent)
      ifnot (is_wrap)
        return -1;

    s._index--;

    if (is_wrap)
      ifnot (s.ptr[1] - s._indent)
        {
        s._findex--;
        return 1;
        }

    s.ptr[1]--;

    0;
  end

  def __right (s, linlen) proc
    if (s._index - s._indent == linlen - 1 || 0 == linlen)
      return -1;

    if (s.ptr[1] < s._maxlen - s._indent - 1)
      {
      s.ptr[1]++;
      s._index++;
      return 0;
      }

    s._index++;
    s._findex++;

    1;
  end

  def __adjust_col (s, linlen, plinlen) proc
    if (linlen == 0 || 0 == s.ptr[1] - s._indent)
      {
      s.ptr[1] = s._indent;
      s._findex = s._indent;
      s._index = s._indent;
      }
    else if (linlen > s._linlen && s.ptr[1] + 1 == s._maxlen ||
      (s.ptr[1] - s._indent == plinlen - 1 && linlen > s._linlen))
        {
        s.ptr[1] = s._maxlen - 1;
        s._findex = s._indent;
        s._index = s._linlen - 1 + s._indent;
        }
    else if ((0 != plinlen && s.ptr[1] - s._indent == plinlen - 1 && (
        linlen < s.ptr[1] || linlen < s._linlen))
       || (s.ptr[1] - s._indent && s.ptr[1] - s._indent >= linlen) ||
         (__vis_wrapped__ (s, plinlen, s._index, s._findex)))
        {
        s.ptr[1] = linlen - 1 + s._indent;
        s._index = linlen - 1 + s._indent;
        s._findex = s._indent;
        }
  end

  def set_modified (s) public proc
    s._flags |= VED_MODIFIED;
  end

  def get_ftype (fn)
    variable ftype = qualifier ("ftype");
    variable ext;

    if (NULL == ftype)
      if (NULL == fn)
        ftype = "txt";
      else
        {
        ext = strtrim_beg (path_extname (fn), ".");
        ifnot (strlen (ext))
          ftype = "txt";
        else
          ftype = ext;
        }

    ifnot (any (assoc_get_keys (FTYPES) == ftype))
      if ("mutt-" == substr (path_basename (fn), 1, 5))
        ftype = "mail";
      else if ("h" == ftype)
        ftype = "c";
      else
        ftype = "txt";

    ftype;
  end

  def! init_ftype (ftype)
    if (NULL == ftype || 0 == any (assoc_get_keys (FTYPES) == ftype))
      ftype = "txt";

    variable type = @Ftype_Type;
    variable f = Env->USER_DATA_PATH + "/ftypes/" + ftype + "/" +
      ftype + "_functions";

    if (-1 == access (f + ".slc", F_OK))
      f = Env->STD_DATA_PATH + "/ftypes/" + ftype + "/" + ftype + "_functions";

    % allow the exception, 
    Load.file (f, NULL); % that merely means a generous fatal
                         % on any error
    type._type = ftype;
    type.set = __get_reference (ftype + "_settype");
    if (NULL == type.set)
      %fatal
      throw ClassError, "Fatal: " + ftype + "_settype (), missing function declaration";

    FTYPES[ftype] = 1;

    type;
  end

  def __get_null_str (indent) proc
    sprintf ("%s\000", repeat (" ", indent));
  end

  def __write_line (fp, line, indent) proc
    line = substr (line, indent + 1, -1);
    return fwrite (line, fp);
  end

  def __vgetlinestr (s, line, ind) public proc
    substr (line, ind + s._indent, s._linlen);
  end

  def __vwritetofile (file, lines, indent, bts) public proc
    variable i, retval,
      append = (NULL == (append = qualifier ("append", 0), append)
       ? 0
       : append),
      fp = fopen (file, ["w", "a+"][append > 0]);

    if (NULL == fp) % fopen sets errno
      return errno;

    _for i (0, length (lines) - 1)
      if (retval = __write_line (fp, lines[i] + "\n", indent), retval == -1)
        return errno;
      else
        @bts += retval;

    if (-1 == fclose (fp))
      return errno;

    0;
  end

  def __vinitrowsbuffvars__ (s) proc
    s.cols = Integer_Type[length (s.rows)];
    s.cols[*] = 0;

    s.clrs = Integer_Type[length (s.rows)];
    s.clrs[*] = 0;
    s.clrs[-1] = VED_INFOCLRFG;

    s._avail_rows = length (s.rows) - 2;
  end

  def __vaddbuf__ (s) proc
    ifnot (access (s._fname, F_OK))
      ifnot (path_is_absolute (s._fname))
        s._abspath = realpath (getcwd () + s._fname);
      else
        s._abspath = realpath (s._fname);
    else % bug on the application logic
      ifnot (path_is_absolute (s._fname))  % cannot be stored as unique
        s._abspath = getcwd () + s._fname;
      else
        s._abspath = s._fname;

    variable w = Ved.get_cur_wind ();

    if (any (s._abspath == w.bufnames))
      return w.buffers[s._abspath];

    w.bufnames = [w.bufnames,  s._abspath];
    w.buffers[s._abspath] = s;
    w.buffers[s._abspath]._dir = qualifier ("_dir",
      realpath (path_dirname (s._abspath)));

    w.buffers[s._abspath];
  end

  def waddlineat (s, line, clr, row, col, len) proc
    Smg.atrcaddnstr (line, clr, row, col, len);
    s.lexicalhl ([line], [row]);
  end

  def waddline (s, line, clr, row) proc
    Smg.atrcaddnstr (line, clr, row, s._indent, s._linlen);
    s.lexicalhl ([line], [row]);
  end

  def __set_clr__ (s, clr, set) proc
    s.clrs[-1] = clr;
    Smg->IMG[s.rows[-1]][1] = clr;
    if (set)
      Smg.hlregion (clr, s.rows[-1], 0, 1, COLUMNS);
  end

  def __vset_clr_fg (s, set) public proc
    __set_clr__ (s, VED_INFOCLRFG, set);
  end

  def __vset_clr_bg (s, set) public proc
    __set_clr__ (s, VED_INFOCLRBG, set);
  end

  def framesize (frames) proc
    variable f = Integer_Type[frames];
    variable ff = Array_Type[frames];
    variable len = length (VED_ROWS);

    f[*] = len / frames;
    f[0] += len mod frames;

    variable i, iend, istart = 0;

    _for i (0, length (f) - 1)
      {
      iend = istart + f[i] - 1;
      ff[i] = VED_ROWS[[istart:iend]];
      istart = iend + 1;
      }

    ff;
  end

  def _vedloopcallback_ (s) proc
    variable retval = (@s.__NOR__["beg"][string (s._chr)]) (s);
    if (-1 == retval)
      return;

    ifnot (retval)
      (@VED_PAGER[string (s._chr)]) (s);

    () = (@s.__NOR__["end"][string (s._chr)]) (s);
  end

  def _loop_ (s) proc
    variable rl, ismsg = 0;

    forever
      {
      s = Ved.get_cur_buf ();
      VEDCOUNT = -1;
      s._chr = Input.getch (;disable_langchange);

      if ('1' <= s._chr <= '9')
        {
        VEDCOUNT = "";

        while ('0' <= s._chr <= '9')
          {
          VEDCOUNT += char (s._chr);
          s._chr = Input.getch (;disable_langchange);
          }

        try
          VEDCOUNT = integer (VEDCOUNT);
        catch SyntaxError:
          {
          ismsg = 1;
          Smg.send_msg_dr ("count: too many digits >= " +
            string (256 * 256 * 256 * 128), 1, s.ptr[0], s.ptr[1]);
          continue;
          }
        }

      s.vedloopcallback ();

      if (ismsg)
        {
        Smg.send_msg_dr (" ", 0, s.ptr[0], s.ptr[1]);
        ismsg = 0;
        }

      if (':' == s._chr && (VED_RLINE || 0 == VED_ISONLYPAGER))
        {
        topline (" -- command --");
        rl = Ved.get_cur_rline ();
        Rline.set (rl);
        Rline.readline (rl;ved = s,
          draw = (@__get_reference ("SCRATCH")) != s._abspath);

        if ('!' == Ved.get_cur_rline ().argv[0][0] &&
           (@__get_reference ("SCRATCH")) == s._abspath)
          {
          (@__get_reference ("__draw_buf")) (s);
          continue;
          }

        topline (" -- pager --");
        s = Ved.get_cur_buf ();
        Smg.setrcdr (s.ptr[0], s.ptr[1]);
        }

      if ('q' == s._chr && VED_ISONLYPAGER)
        return 1;
      }

    0;
  end

  def _vedloop_ (s) proc
    if (_loop_ (s))
      return;
  end

  def autoindent (s, indent, line) proc
    % lookup for a (not private) type_autoindent
    variable f = __get_reference (s._type + "_autoindent");
    % call it (if exists) and calc the value
    if (NULL == f)
    % else calculate the value as:
      @indent =  s._indent + (s._autoindent ? s._shiftwidth : 0);
    else
      @indent = (@f) (s, line);
  end

  def lexicalhl (s, lines, vlines) proc
  end

  def _on_lang_change_ (mode, ptr) public proc
    topline (" -- " + mode + " --");
    Smg.setrcdr (ptr[0], ptr[1]);
  end

  def __on_keypress__ (s) proc
    0;
  end

  def __init_fun_norm__ () proc
    Assoc.new (Assoc_Type, ["beg", "end"],
      [Assoc.new (Ref_Type, NULL, NULL;default = &__on_keypress__),
       Assoc.new (Ref_Type, NULL, NULL;default = &__on_keypress__)]);
  end

  def __init_fun_all__ (s) proc
    if (NULL == s.__NOR__)
      s.__NOR__ = __init_fun_norm__ (;;__qualifiers);
  end

  def __init_var__ () proc
    Assoc.new (Any_Type, NULL, NULL);
  end

%%% ___v

  def __vlinlen (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    strlen (s.lins[r]) - s._indent;
  end

  def __vline (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    s.lins[r];
  end

  def __vlnr (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    s.lnrs[r];
  end

  def __vdraw_tail (s) public proc
    variable linlen = __vlinlen (s, '.');

    if (linlen > s._linlen && s._findex < linlen - s._linlen)
      Smg.hlregion (2, s.ptr[0], s._indent + s._linlen - 2, 1, 2);

    Smg.atrcaddnstrdr (Ved.tail (s;;struct {@__qualifiers (), linlen = linlen}),
      [Smg->NOCOLOR, VED_INFOCLRFG][s.opt_show_status_line > 0],
      s.rows[-1], 0, s.ptr[0], s.ptr[1], COLUMNS);
  end

  def _draw_ (s) proc
    if (0 > s._len) % this shouldn't never occur (simple means that
      {             % something went wrong and needs fixing at the cause)
      __vdebug ("_draw_ (), caught unacceptable s._len condition, " +
         s._fname;hold);
      s.lins = [__get_null_str (s._indent)];
      s.lnrs = [0];
      s._ii = 0;

      Smg.aratrcaddnstrdr ([repeat (" ", COLUMNS), Ved.vtail (s)],
        [0, s.opt_show_status_line ? VED_INFOCLRFG : Smg->NOCOLOR],
        [s.rows[0], s.rows[-1]], [0, 0], s.rows[0], 0, COLUMNS);

      return;
      }

    s.lnrs = Integer_Type[0];
    s.lins = String_Type[0];

    variable
      i = s.rows[0],
      ar = String_Type[0];

    s._ii = s._i;

    while (s._i <= s._len && i <= s.rows[-2])
      {
      s.lnrs = [s.lnrs, s._i];
      s.lins = [s.lins, s.lines[s._i]];
      s._i++;
      i++;
      }

    s.vlins = [s.rows[0]:s.rows[0] + length (s.lins) - 1];

    s._i = s._i - (i) + s.rows[0];

    if (-1 == s._i)
      s._i = 0;

    if (s.ptr[0] >= i)
      s.ptr[0] = i - 1;

    ar = array_map (String_Type, &substr, s.lins, 1, s._maxlen);

    variable indices = [0:length (ar) - 1];
    variable clrs = @s.clrs;
    variable arlen = length (ar);
    variable rowslen = length (s.rows);

    if (arlen < rowslen - 1)
      {
      ifnot (s._type == "ashell")
        clrs[[arlen:length (clrs) -2]] = 5;

      variable t = String_Type[rowslen - arlen - 1];
      t[*] = s.opt_show_tilda ? "~" : " ";
      ar = [ar, t];
      }

    ar = [ar, Ved.tail (s;;__qualifiers ())];

    clrs[-1] = [Smg->NOCOLOR, VED_INFOCLRFG][s.opt_show_status_line > 0];

    Smg.set_img (s.rows, ar, clrs, s.cols);

    Smg.aratrcaddnstr (ar, clrs, s.rows, s.cols, COLUMNS);

    s.lexicalhl (ar[indices], s.vlins);

    (@[Smg.setrcdr, Smg.setrc][qualifier_exists ("dont_draw")]) (Smg, s.ptr[0], s.ptr[1]);
  end


  include self from Ved as Ved

  require topline from wind

  def __vfpart_of_word (s, line, col, start) proc
    ifnot (strlen (line))
      return "";

    variable origcol = col;

    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent &&
        any (WCHARS == substr (line, col + 1, 1)));

      @start = col + 1;
      }

    substr (line, @start + 1, origcol - @start + 1);
  end

  def __vfind_word (s, line, col, start, end) public proc
    if (0 == strlen (line) || ' ' == line[col] ||
        0 == any (WCHARS == char (line[col])))
      return "";

    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent &&
        any (WCHARS == substr (line, col + 1, 1)));

      @start = col + 1;
      }

    variable len = strlen (line);

    while (col++, col < len && any (WCHARS == substr (line, col + 1, 1)));

    @end = col - 1;

    substr (line, @start + 1, @end - @start + 1);
  end

  def __vfind_Word (s, line, col, start, end) proc
    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent && 0 == isblank (substr (line, col + 1, 1)));

      @start = col + 1;
      }

    variable len = strlen (line);

    while (col++, col < len && 0 == isblank (substr (line, col + 1, 1)));

    @end = col - 1;

    substr (line, @start + 1, @end - @start + 1);
  end

  def __get_dec (chr, dir) proc
    any ([['0':'9'], '.'] == chr);
  end

  def __get_hex (chr, dir) proc
    any (chr == ("lhs" == dir ? ['0'] : [['0':'9'], ['a':'f'], ['A':'F'], 'x']));
  end

  def __vfind_nr (indent, line, col, start, end, ishex, isoct, isbin) proc
    ifnot (any ([['0':'9'], '-', '.', 'x'] == line[col]))
      return "";

    variable mbishex = 0;
    variable getfunc = [&__get_dec, &__get_hex];

    @ishex = 'x' == line[col];
    getfunc = getfunc[@ishex];

    ifnot (col - indent)
      @start = indent;
    else
      {
      ifnot (line[col] == '-')
        while (col--, col >= indent && (@getfunc) (line[col], "lhs"));

      @start = col + 1;

      if (col)
        if (line[col] == '-')
          @start--;
        else if (line[col] == 'x') % maybe is hex
          mbishex = 1; % when at least one digit found, and 'x' is not the char 
      }                % where the matching stopped. the string under the cursor
                       % can form a valid hex number
    variable len = strlen (line);

    while (col++, col < len && (@getfunc) (line[col], "rhs"));

    @end = col - 1;

    variable nr = substr (line, @start + 1, @end - @start + 1);

    if (nr == "-" || nr == "." || nr[0] == '.' || 0 == strlen (nr))
      return "";

    if (1 == strlen (nr))
      if ('0' == nr[0])
        if (col < len)
          ifnot (@ishex)
            if ('x' == line[col])
              mbishex = 1;

    % hex incr/decr is done when cursor is on an 'x'
    if (mbishex)  % for now and for both conditions and for safety, refuse
      return "";  % to modify the string, if an 'x' is found on the string

    len = strlen (nr);
    col = 0;

    ifnot (len mod 4)
      while (col++, col < len && (@isbin = any (['0','1'] == nr[col]), @isbin));

    col = 0;

    if (1 < len && 0 == @isbin)
      if ('0' == nr[0])
        while (col++, col < len && (@isoct = any (['0':'7'] == nr[col]), @isoct));

    if (nr[-1] == '.')
      if (len > 1)
        {
        nr = substr (nr, 1, len - 1);
        @end--;
        }
      else
        return "";

    if (@ishex || @isoct || @isbin)
      try
        return string (integer (sprintf ("%s%s", @isbin ? "0b" : "", nr)));
      catch SyntaxError:
        return "";

    nr;
  end

  def on_wind_change (w) public proc
  end

  def get_wind_name ()
    VED_CUR_WIND;
  end

  def get_wind_names ()
    variable winds = assoc_get_keys (VED_WIND);
    winds[array_sort (winds)];
  end

  def wind_change (to)
    variable winds = get_wind_names (NULL);

    variable w;
    variable i;

    if (Integer_Type == typeof (to))
      if (length (winds) - 1 < to)
        return;
      else
        w = winds[to];
    else
      ifnot (any ([",", "."] == to))
        return;
      else
        if (to == ",")
          w = winds[wherefirst (winds == VED_CUR_WIND) - 1];
        else
          {
          i = wherefirst (winds == VED_CUR_WIND);
          i = i == length (winds) - 1 ? 0 : i + 1;
          w = winds[i];
          }

    if (w == VED_CUR_WIND)
      return;

    VED_PREV_WIND = VED_CUR_WIND;
    VED_CUR_WIND = w;

    w = VED_WIND[w];

    on_wind_change (w);

    Ved.draw_wind ();
  end

  def next_wind (s) public proc
    if (This.has.new_windows)
      wind_change (NULL, ".");
  end

  def on_wind_new (w) public proc
    (@__get_reference ("__initrline"));
  end

  def wind_init (name, frames) public proc
    if (any (name == assoc_get_keys (VED_WIND)) && 0 == qualifier_exists ("force"))
      return;

    variable setframesize = __get_qualifier_as (Ref_Type, qualifier ("framesize_fun"),
        This.framesize);

    if (NULL == setframesize)
      setframesize = &framesize;

    VED_WIND[name] = @Wind_Type;
    VED_WIND[name].name = name;
    VED_WIND[name].frames = frames > This.has.max_frames
      ? This.has.max_frames
      : frames < 1
        ? 1
        : frames;
    VED_WIND[name].frame_names = String_Type[VED_WIND[name].frames];
    VED_WIND[name].frame_rows = (@setframesize) (VED_WIND[name].frames);
    VED_WIND[name].cur_frame = 0;
    VED_WIND[name].buffers = Assoc_Type[Ftype_Type];
    VED_WIND[name].bufnames = String_Type[0];
    VED_WIND[name].prev_buf_ind = -1;

    if (qualifier_exists ("on_wind_new"))
      on_wind_new (VED_WIND[name]);
  end

  def new_wind () proc
    variable name = _NARGS ? () : NULL;

    variable i;
    variable winds = assoc_get_keys (VED_WIND);
    variable frames = __get_qualifier_as (Integer_Type, qualifier ("frames"), This.has.frames);

    if (NULL == frames)
      frames = 1;

    if (any (name == winds))
      return;

    if (NULL == name)
      _for i ('a', 'z')
        {
        name = char (i);
        ifnot (any (name == winds))
          break;

        if ('z' == i)
          return;
        }

    ifnot (qualifier_exists ("in_bg"))
      {
      VED_PREV_WIND = VED_CUR_WIND;
      VED_CUR_WIND = name;
      }

    wind_init (name, frames;;__qualifiers ());

    if (qualifier_exists ("draw_wind"))
      Ved.draw_wind ();
  end

  def bufdelete (s, bufname, force) public proc
    if (any (bufname == UNDELETABLE))
      return;

    variable w = Ved.get_cur_wind ();

    ifnot (any (bufname == w.bufnames))
      return;

    if (s._flags & VED_MODIFIED && force)
      {
      variable bts = 0;
      variable retval = __vwritetofile (bufname, s.lines, s._indent, &bts);
      ifnot (0 == retval)
        {
        Smg.send_msg_dr (errno_string (retval), 1, NULL, NULL);
        return;
        }
      }

    variable isatframe = wherefirst (w.frame_names == bufname);
    variable iscur = Ved.get_cur_bufname () == bufname;

    assoc_delete_key (w.buffers, bufname);

    variable i = wherefirst (bufname == w.bufnames);

    w.bufnames[i] = NULL;
    w.bufnames = w.bufnames[wherenot (_isnull (w.bufnames))];

    variable winds = assoc_get_keys (VED_WIND);

    ifnot (length (w.bufnames))
      if (1 == length (winds))
        exit_me (0);
      else
        {
        assoc_delete_key (VED_WIND, VED_CUR_WIND);
        winds = assoc_get_keys (VED_WIND);
        VED_CUR_WIND = winds[0];
        w = Ved.get_cur_wind ();
        s = Ved.get_cur_buf ();
        Ved.setbuf (s._abspath);
        Ved.draw_wind ();
        return;
        }

    ifnot (NULL == isatframe)
      if (1 < w.frames)
        Ved.del_frame (isatframe);

    if (iscur)
      {
      variable notfound = 1;

      loop (length (w.bufnames))
        {
        i = i ? i - 1 : length (w.bufnames) - 1;
        if (any (w.bufnames[i] == SPECIAL))
          continue;

        notfound--;
        break;
        }

      if (notfound)
        {
        Smg.send_msg_dr ("There is no normal buffer loaded, press q to exit",
          1, NULL, NULL);

        if ('q' == Input.getch ())
          exit_me (0);
        }

      Ved.setbuf (w.bufnames[i]);

      s = Ved.get_cur_buf ();
      s.draw ();
      }
  end

  subclass Mark from Ved

  beg
    MARKS[string ('`')] = struct {pos = @Pos_Type, linlen};
  end

  def preloop (s)
    Ved.Mark.backtick (s);
  end

  def __hl_groups (s, lines, vlines, colors, regexps) public proc
    variable
      i,
      ii,
      col,
      subs,
      match,
      color,
      regexp,
      line,
      iscomment = 0,
      context;

    _for i (0, length (lines) - 1)
      {
      line = lines[i];
      if (0 == strlen (line) || "\000" == line)
        continue;

      iscomment = any (0 == array_map (Integer_Type, &strncmp,
        strtrim_beg (line), s.comment_str, strlen (s.comment_str)));

      _for ii (0, length (regexps) - 1)
        {
        color = colors[ii];
        regexp = regexps[ii];
        col = 0;

        if (ii && iscomment)
          break;

          %!  invalid index - check arrays for NULL
        while (subs = pcre_exec (regexp, line, col), subs > 1)
          {
          match = pcre_nth_match (regexp, 1);
          % revailed by (see) diff.syntax
          % maybe add a check for NULL
          % my opinion is that the check hides the code mistake
          % somewhere in the pattern related code, independently
          % of the designed highlighting implementation (which in that
          % state needs improvement),the code should provide expected
          % results, (assuming the toolchain has no weakness, (which in that
          % case it has (and I have to find why (and I'm boring for that
          % kind of thing (...
          col = match[0];
          context = match[1] - col;
          %% subs > 1 (in that case four),
          % but match is NULL (though changing from
          % 1 (the first submatch) to either the rest of the three succeeds,
          % so we end up with an invalid index
          %.
          Smg.hlregion (color, vlines[i], col, 1, context);
          col += context;
          }

        ifnot (ii)
          if (col)                  % + 1 is to avoid the error pattern
            line = substr (line, 1, match[0] + 1); % to match it as eol
        }
      }
  end

  def __vreread (s) public proc
    s.lines = Ved.getlines (s._abspath, s._indent, s.st_);

    s._len = length (s.lines) - 1;

    ifnot (s._len)
      {
      s._ii = 0;
      s.ptr[0] = s.rows[0];
      }
    else if (s._ii < s._len)
      while (s.ptr[0] - s.rows[0] + s._ii > s._len)
        s.ptr[0]--;
    else
      {
      while (s._ii > s._len)
        s._ii--;

      s.ptr[0] = s.rows[0];
      }

    s.ptr[1] = 0;

    s._i = s._ii;

    s.draw ();
  end

  def _change_frame_ (s) public proc
    Ved.change_frame (;;__qualifiers);
    s = Ved.get_cur_buf ();
  end

  def _new_frame_ (s) public proc
    ifnot (VED_OPTS.new_frame)
      return;

    Ved.new_frame (VED_DIR + "/" + string (_time) + ".noname";
      _autochdir = 0, _dir = Ved.get_cur_buf ()._dir);
    s = Ved.get_cur_buf ();
  end

  def _del_frame_ (s) proc
    ifnot (VED_OPTS.del_frame)
      return;

    Ved.del_frame ();
    s = Ved.get_cur_buf ();
  end

  def _del_wind_ (s) proc
    ifnot (VED_OPTS.new_wind)
      return;

    Ved.del_wind (VED_CUR_WIND);
    s = Ved.get_cur_buf ();
  end

  def on_wind_change (w) proc
    topline (" -- ved --");
    Ved.setbuf (w.frame_names[w.cur_frame]);
  end

  def on_wind_new (w) public proc
    variable fn = VED_DIR + "/" + string (_time) + ".noname";
    variable s = Ved.init_ftype (NULL;;__qualifiers);
    s.set (fn, w.frame_rows[0], NULL;_autochdir = 0);

    Ved.setbuf (fn;;__qualifiers);

    SPECIAL = [SPECIAL, fn];

    (@__get_reference ("__initrline"));
    topline (" -- ved --");
    Ved.draw_wind ();
  end

  def _new_wind_ (s) public proc
    ifnot (VED_OPTS.new_wind)
      return;

    new_wind (;on_wind_new);
    s = Ved.get_cur_buf ();
  end

  def _goto_wind_ (s, chr) proc
    ifnot (VED_OPTS.new_wind)
      return;

    if (any (['0':'9'] == chr))
      chr = int (chr - '0');
    else
      chr = char (chr);

    wind_change (NULL, chr);
    s = Ved.get_cur_buf ();
  end

  def handle_w (s) public proc
    variable chr = Input.getch ();

    if (any (['w', 's', Input->UP, Input->CTRL_w, Input->DOWN, 'd', 'k', 'n', ',', '.', ['0':'9']] == chr))
      {
      if (any (['w', Input->CTRL_w, Input->DOWN] == chr))
        {
        _change_frame_ (s;dir = "next");
        return;
        }

      if (any ([Input->UP] == chr))
        {
        _change_frame_ (s;dir = "prev");
        return;
        }

      if ('s' == chr)
        {
        _new_frame_ (s);
        return;
        }

      if ('d' == chr)
        {
        _del_frame_ (s);
        return;
        }

      if ('k' == chr)
        {
        _del_wind_ (s);
        return;
        }

      if ('n' == chr)
        {
        _new_wind_ (s);
        return;
        }

      if (any ([['0':'9'], ',', '.'] == chr))
        {
        _goto_wind_ (s, chr);
        return;
        }
      }
  end

  def __pg_on_carriage_return (s) public proc
  end

  def __write_on_esc__ (s) proc
    Ved.writefile (s, NULL, s.ptr, NULL, NULL);
    Smg.send_msg_dr ("", 14, NULL, NULL);
    sleep (0.001);
    Smg.setrcdr (s.ptr[0], s.ptr[1]);
  end

  def _set_nr_ (s, incrordecr) proc
    variable
      count = qualifier ("count", 1),
      end,
      start,
      nr,
      col = s._index,
      i = __vlnr (s, '.'),
      line = __vline (s, '.');

    variable ishex = 0;
    variable isoct = 0;
    variable isbin = 0;

    nr = __vfind_nr (s._indent, line, col, &start, &end, &ishex, &isoct, &isbin);
    ifnot (strlen (nr))
      {
      nr = String.decode (line)[col];

      if ("+" == incrordecr)
        nr += count;
      else
        nr -= count;

      if (any (nr ==  [[0:31], ['~' + 1:160]]))
        return;

      line = sprintf ("%s%c%s", substr (line, 1, col), nr, substr (line, col + 2, -1));

      s.lins[s.ptr[0] - s.rows[0]] = line;
      s.lines[i] = line;
      set_modified (s);

      s.st_.st_size = Array.String.__len (s.lines, s._len);

      waddline (s, line, 0, s.ptr[0]);

      __vdraw_tail (s);
      return;
      }

    variable isdbl = _slang_guess_type (nr) == Double_Type;
    variable convf = [&atoi, &atof];
    convf = convf[isdbl];

    if ("+" == incrordecr)
      nr = (@convf) (nr) + count;
    else
      nr = (@convf) (nr) - count;

    variable format = sprintf ("%s%%%s",
      ishex ? "0x0" : isoct ? "0" : "",
      ishex ? "x" : isoct ? "o" : isbin ? "B" : isdbl ? ".3f" : "d");

    nr = sprintf (format, nr);

    if (isbin)
      while (strlen (nr) mod 4)
        nr = "0" + nr;

    line = sprintf ("%s%s%s", substr (line, 1, start), nr, substr (line, end + 2, -1));

    s.lins[s.ptr[0] - s.rows[0]] = line;
    s.lines[i] = line;
    s.ptr[1] = start;
    s._index = start;

    set_modified (s);

    s.st_.st_size = Array.String.__len (s.lines, s._len);

    waddline (s, line, 0, s.ptr[0]);

    __vdraw_tail (s);
  end

  def _incr_nr_ (s) proc
    _set_nr_ (s, "+";count = VEDCOUNT == -1 ? 1 : VEDCOUNT);
  end

  def _decr_nr_ (s) proc
    _set_nr_ (s, "-";count = VEDCOUNT == -1 ? 1 : VEDCOUNT);
  end

  def __undo__ (s) proc
    Ved.Vundo.undo (s);
  end

  def __redo__ (s) proc
    Ved.Vundo.redo (s);
  end

  subclass Pager from Ved
  subclass Search from Ved
  subclass Ed from Ved
  subclass Insert from Ved
  subclass Vundo from Ved
  subclass Visual from Ved

  def init_search_hist () proc
    variable ar = NULL;
    ifnot (access (SEARCH_HISTFILE, F_OK|R_OK))
      ar = File.readlines (SEARCH_HISTFILE);
    if (NULL != ar && length (ar))
      {
      array_map (&list_append, SEARCH_HISTORY, ar);
      SEARCH_HISTINDEX = 0;
      }
  end

  beg
    init_search_hist ();
  end

  def __Yank__ (s) proc
    variable
      reg = qualifier ("reg", "\""),
      line = __vline (s, '.');

    Ved.Reg.set (reg, line + "\n");
    seltoX (line + "\n");
    Smg.send_msg_dr ("yanked", 1, s.ptr[0], s.ptr[1]);
  end

  def __register__ (s) proc
    variable reg = Input.getch ();
    ifnot (any (VedReg->REGS == reg))
      return;

    reg = char (reg);

    variable chr = Input.getch ();
    ifnot (any (['D', 'c', 'd', 'Y', 'p', 'P', 'x', 'X', Input->rmap.delete]
      == chr))
      return;

    if (any (['x', 'X', Input->rmap.delete] == chr))
      Ved.Ed.del_chr (s;reg = reg, chr = chr);
    else if ('Y' == chr)
      __Yank__ (s;reg = reg);
    else if ('d' == chr)
      Ved.Ed.del (s;reg = reg);
    else if ('c' == chr)
      Ved.Ed_change (s;reg = reg);
    else if ('D' == chr)
      Ved.Ed.del_to_end (s;reg = reg);
    else if ('P' == chr)
      Ved.Ed.Put (s;reg = reg);
    else
      Ved.Ed.Put (s;reg = reg);
  end

  def __askonsubst__ (s, fn, lnr, fpart, context, lpart, replace) proc
    variable cmp_lnrs = Integer_Type[0];
    variable ar =
      ["@" + fn + " linenr: " + string (lnr+1),
       "replace?",
       Smg.__HLINE__ (),
       sprintf ("%s%s%s", fpart, context, lpart),
       Smg.__HLINE__ (),
       "with?",
       Smg.__HLINE__ (),
       sprintf ("%s%s%s", fpart, replace, lpart),
       Smg.__HLINE__ (),
       "y[es]/n[o]/q[uit]/a[ll]/c[ansel]"];

    variable hl_reg = Array_Type[2];
    hl_reg[0] = [5, PROMPTROW - 8, strlen (fpart), 1, strlen (context)];
    hl_reg[1] = [2, PROMPTROW - 4, strlen (fpart), 1, strlen (replace)];

    variable char_ar =  ['y', 'n', 'q', 'a', 'c'];
    Smg.askprintstr (ar, char_ar, &cmp_lnrs;hl_region = hl_reg);
  end

  def __delete__ (buf, pat, lnrs, whenmatch) proc
    variable lnr, line, len, i;
    ifnot (NULL == pat)
      { % code style violation (clever)
      variable __pcre_exec = __Fexpr (`(pat, line)
      try
        {
        pcre_exec (pat, line, 0);
        }
      catch AnyError:
        {
        Exc.print (NULL);
        0;
        }
        `);

    _for i (0, length (lnrs) -1)
      {
      lnr = lnrs[i];
      line = buf.lines[lnr];
      if (__pcre_exec.__ (pat, line))
        ifnot (whenmatch)
          continue;
        else
          buf.lines[lnr] = NULL;
      else
        ifnot (whenmatch)
          buf.lines[lnr] = NULL;
      }

    }
  else % end of code style violation
    buf.lines[[lnrs[0]:lnrs[-1]]] = NULL;

    variable nulllines = _isnull (buf.lines);

    len = buf._len - length (nulllines);

    buf.lines = buf.lines[wherenot (nulllines)];
    buf._len = length (buf.lines) - 1;

    buf._i = buf._ii - len;
    if (0 > buf._i)
      buf._i = 0;

    buf._index = buf._indent;
    buf._findex = buf._indent;
    buf.ptr[0] = buf.rows[0];
    buf.ptr[1] = buf._indent;

    if (-1 == buf._len)
      {
      buf.lines = [__get_null_str (buf._indent)];
      buf._len = 0;
      buf._i = 0;
      }

    buf.st_.st_size = Array.String.__len (buf.lines, buf._len + 1);
    set_modified (buf);
    buf.draw ();
  end

  def __write__ (buf, pat, lnrs, whenmatch) proc
    variable rl = Ved.get_cur_rline ();
    variable argv = ["w", "--bufname=" + buf._abspath,
      sprintf ("--range=%d,%d", lnrs[0], lnrs[-1])];

     Rline.set (rl;line = strjoin (argv, " "), argv = argv,
       col = int (sum (strlen (argv))) + length (argv),
       ind = length (argv) - 1);

     Rline.readline (rl);
  end

  def __global () public proc
    variable global = 0,
             whenmatch = 1,
             ask = 1,
             pat = NULL,
             action = NULL,
             ind, range = NULL;
    variable args = __pop_list (_NARGS);
    variable buf = Ved.get_cur_buf ();
    variable lnrs = [0:buf._len];

    args = list_to_array (args, String_Type);

    pat = Opt.Arg.getlong ("pat", NULL, &args;del_arg);
    action = Opt.Arg.getlong ("action", NULL, &args;del_arg);
    whenmatch = NULL == Opt.Arg.exists ("--whenNotMatch", &args;del_arg);

    if (NULL == action || 0 == strlen (action))
      {
      Smg.send_msg_dr ("--action= argument is required, supported are [write, delete]", 1, buf.ptr[0], buf.ptr[1]); 
      return;
      }

    ifnot (any (action == ["delete", "write"]))
      {
      Smg.send_msg_dr ("supported actions are [delete,write]", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    if (NULL == (lnrs = Opt.Arg.getlong ("range", "range", &args;fun_args =
        {buf, lnrs}, del_arg, defval = lnrs), lnrs))
      return;

    ifnot (NULL == pat)
    try
      {
      pat = pcre_compile (pat, PCRE_UCP|PCRE_UTF8|PCRE_NO_UTF8_CHECK);
      }
    catch ParseError:
      {
      IO.tostderr (__get_exception_info.message);
      Smg.send_msg_dr ("Error while compiling pattern", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    if (action == "write")
      __write__ (buf, pat, lnrs, whenmatch);
    else
     __delete__ (buf, pat, lnrs, whenmatch);
  end

  def __substitute () public proc
    variable global = 0, ask = 1, pat = NULL, sub = NULL, range = NULL;
    variable args = __pop_list (_NARGS);
    variable buf = Ved.get_cur_buf ();
    variable lnrs = [0:buf._len];

    args = list_to_array (args, String_Type);

    pat = Opt.Arg.getlong ("pat", NULL, &args;del_arg, ret_arg);
    sub = Opt.Arg.getlong ("sub", NULL, &args;del_arg, ret_arg);

    if (NULL == pat || NULL == sub || any (0 == strlen ([pat, sub])))
      {
      Smg.send_msg_dr ("--pat= and --sub= are required", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    global = (NULL != Opt.Arg.exists ("--global", &args;del_arg));
    ask = (NULL == Opt.Arg.exists ("--dont-ask-when-subst", &args;del_arg));

    if (NULL == (lnrs = Opt.Arg.getlong ("range", "range", &args;fun_args =
       {buf, lnrs}, del_arg, defval = lnrs), lnrs))
      {
       Smg.send_msg_dr (Opt.err ());
       return;
       }

    variable s = Subst.new (pat, sub;
      fname = buf._abspath, global = global, askwhensubst = ask,
      askonsubst = &__askonsubst__);

    if (NULL == s)
      {
      variable err = ();
      IO.tostderr (err);
      return;
      }

    variable retval = Subst.exec (s, buf.lines[lnrs]);

    ifnot (retval)
      {
      variable ar= ();
      ifnot (length (ar) == length (lnrs))
        {
        ifnot (lnrs[0])
          ifnot (lnrs[-1] == buf._len)
            buf.lines = [ar, buf.lines[[lnrs[-1] + 1:]]];
          else
            buf.lines = ar;
        else
          ifnot (lnrs[-1] == buf._len)
            buf.lines = [buf.lines[[:lnrs[0] - 1]], ar, buf.lines[[lnrs[-1] + 1:]]];
          else
            buf.lines = [buf.lines[[:lnrs[0] - 1]], ar];

        buf._len = length (buf.lines) - 1;
        }
      else
        buf.lines[lnrs] = ar;

      buf.st_.st_size = Array.String.__len (buf.lines, buf._len + 1);

      set_modified (buf);
      buf.draw ();
      }
  end

  def PROJECT_VED (argv) public proc
    ifnot (length (argv) - 1)
      return;

    variable pj;
    variable fn;
    variable args = argv[[1:]];

    variable ind = Opt.Arg.compare ("--from-file=", &args);
    ifnot (NULL == ind)
      {
      fn = strchop (args[ind], '=', 0);
      if (1 == length (fn))
        return;

      fn = fn[1];

      if (-1 == access (fn, F_OK|R_OK))
        return;

      variable ar = File.readlines (fn);

      pj = strtok (ar[0]);
      }
    else
      pj = args;

    if (length (pj) + length (assoc_get_keys (VED_WIND)) > 10)
      return;

    variable wc = VED_CUR_WIND, i, w = NULL, j, found,
      nwns,owns = assoc_get_keys (VED_WIND);

    _for i (0, length (pj) - 1)
      {
      fn = pj[i];
      if (access (fn, F_OK|R_OK))
        continue;

      new_wind (;on_wind_new);

      nwns = assoc_get_keys (VED_WIND);

      if (length (nwns) == length (owns))
        continue;

      _for j (0, length (nwns) - 1)
        if (any (nwns[j] == owns))
          continue;
        else
          {
          w = nwns[j];
          break;
          }

      owns = @nwns;

      variable cw, ft, s;
      cw = Ved.get_cur_wind ();
      ft = Ved.get_ftype (fn;;__qualifiers);
      s = Ved.init_ftype (ft;;__qualifiers);
      s.set (fn, cw.frame_rows[Ved.get_cur_frame ()], NULL;;__qualifiers);
      Ved.setbuf (s._abspath;;__qualifiers);
      }

    if (NULL == w)
      return;

    VED_PREV_WIND = wc;
    VED_CUR_WIND = w;

    Ved.draw_wind ();
  end

  def __gotomark__ (s) proc
    Ved.Mark.goto (s);
  end

  def __mark__ (s) proc
    Ved.Mark.set (s);
  end

  def __indent_in__ (s) proc
    Ved.Ed.indent_in (s);
  end

  def __indent_out__ (s) proc
    Ved.Ed.indent_out (s);
  end

  def __join_line__ (s) proc
    Ved.Ed.join_line (s);
  end

  def __del_to_end__ (s) proc
    Ved.Ed.del_to_end (s);
  end

  def __change_chr__ (s) proc
    Ved.Ed.change_chr (s);
  end

  def __del_trail_ws__ (s) proc
    Ved.Ed.del_trail_ws (s);
  end

  def __del_chr__ (s) proc
    Ved.Ed.del_chr (s);
  end

  def __toggle_case__ (s) proc
    Ved.Ed.toggle_case (s);
  end

  def __del__ (s) proc
    Ved.Ed.del (s);
  end

  def __change__ (s) proc
    Ved.Ed.change (s);
  end

  def __put__ (s) proc
    Ved.Ed.put (s);
  end

  def __Put__ (s) proc
    Ved.Ed.Put (s);
  end

  def __newline__ (s) proc
    Ved.Ed.newline (s);
  end

  def __editline__ (s) proc
    Ved.Ed.editline (s);
  end

  def __search__ (s) proc
    Ved.Search.run (s);
  end

  def __search_word__ (s) proc
    Ved.Search.word (s);
  end

  def __search_last__ (s) proc
    Ved.Search.last (s);
  end

  def __visual__ (s) proc
    Ved.Visual.mode (s);
  end

  def handle_comma (s) public proc
    variable chr = Input.getch ();

    ifnot (any (['p'] == chr))
      return;

    if ('p' == chr)
      seltoX (Ved.get_cur_buf ()._abspath);
  end

  def __space__ (s) proc
    Ved.Pager.page_down (s);
  end

  def __up__ (s) proc
    Ved.Pager.up (s);
  end

  def __down__ (s) proc
    Ved.Pager.down (s);
  end

  def __left__ (s) proc
    Ved.Pager.left (s);
  end

  def __right__ (s) proc
    Ved.Pager.right (s);
  end

  def __bol__ (s) proc
    Ved.Pager.bol (s);
  end

  def __bof__ (s) proc
    Ved.Pager.bof (s);
  end

  def __eol__ (s) proc
    Ved.Pager.eol (s);
  end

  def __eos__ (s) proc
    Ved.Pager.eos (s);
  end

  def __eof__ (s) proc
    Ved.Pager.eof (s);
  end

  def __bolnblnk__ (s) proc
    Ved.Pager.bolnblnk (s);
  end

  def __g__ (s) proc
    Ved.Pager.g (s);
  end

  def __gotoline__ (s) proc
    Ved.Pager.gotoline (s);
  end

  def __word_change_case__ (s) proc
    Ved.Pager.word_change_case (s);
  end

  def __end_word__ (s) proc
    Ved.Pager.end_word (s);
  end

  def __page_up__ (s) proc
    Ved.Pager.page_up (s);
  end

  def __page_down__ (s) proc
    Ved.Pager.page_down (s);
  end

  beg
    VED_PAGER[string (Input->rmap.windnext[0])] = &next_wind;
    VED_PAGER[string (Input->F12)]              = &paste_xsel;
    VED_PAGER[string (',')]            = &handle_comma;
    VED_PAGER[string ('"')]            = &__register__;
    VED_PAGER[string (Input->CTRL_a)]  = &_incr_nr_;
    VED_PAGER[string (Input->CTRL_x)]  = &_decr_nr_;
    VED_PAGER[string (Input->CTRL_l)]  = &__vreread;
    VED_PAGER[string (Input->UP)]      = &__up__;
    VED_PAGER[string (Input->DOWN)]    = &__down__;
    VED_PAGER[string (Input->ESC_esc)] = &__write_on_esc__;
    VED_PAGER[string (Input->HOME)]    = &__bof__;
    VED_PAGER[string (Input->NPAGE)]   = &__page_down__;
    VED_PAGER[string (Input->CTRL_f)]  = &__page_down__;
    VED_PAGER[string (Input->CTRL_b)]  = &__page_up__;
    VED_PAGER[string (Input->PPAGE)]   = &__page_up__;
    VED_PAGER[string (Input->RIGHT)]   = &__right__;
    VED_PAGER[string (Input->LEFT)]    = &__left__;
    VED_PAGER[string (Input->END)]     = &__eol__;
    VED_PAGER[string (Input->CTRL_w)]  = &handle_w;
    VED_PAGER[string (Input->CTRL_r)]  = &__redo__;
    VED_PAGER[string (Input->CTRL_v)]  = &__visual__;
    VED_PAGER[string (Input->BSLASH)]  = &__search__;
    VED_PAGER[string (Input->QMARK)]   = &__search__;
    VED_PAGER[string ('#')]            = &__search_word__;
    VED_PAGER[string ('*')]            = &__search_word__;
    VED_PAGER[string ('n')]            = &__search_last__;
    VED_PAGER[string ('N')]            = &__search_last__;
    VED_PAGER[string (033)]            = &pag_completion;
    VED_PAGER[string ('\r')]           = &__pg_on_carriage_return;
    VED_PAGER[string ('`')]            = &__gotomark__;
    VED_PAGER[string ('Y')]            = &__Yank__;
    VED_PAGER[string ('j')]            = &__down__;
    VED_PAGER[string ('k')]            = &__up__;
    VED_PAGER[string ('G')]            = &__eof__;
    VED_PAGER[string ('g')]            = &__g__;
    VED_PAGER[string (' ')]            = &__space__;
    VED_PAGER[string ('e')]            = &__end_word__;
    VED_PAGER[string ('l')]            = &__right__;
    VED_PAGER[string ('h')]            = &__left__;
    VED_PAGER[string ('-')]            = &__eos__;
    VED_PAGER[string ('$')]            = &__eol__;
    VED_PAGER[string ('^')]            = &__bolnblnk__;
    VED_PAGER[string ('0')]            = &__bol__;
    VED_PAGER[string ('u')]            = &__undo__;
    VED_PAGER[string ('v')]            = &__visual__;
    VED_PAGER[string ('V')]            = &__visual__;
    VED_PAGER[string ('m')]            = &__mark__;
    VED_PAGER[string ('C')]            = &__editline__;
    VED_PAGER[string ('i')]            = &__editline__;
    VED_PAGER[string ('a')]            = &__editline__;
    VED_PAGER[string ('A')]            = &__editline__;
    VED_PAGER[string ('o')]            = &__newline__;
    VED_PAGER[string ('O')]            = &__newline__;
    VED_PAGER[string ('P')]            = &__Put__;
    VED_PAGER[string ('p')]            = &__put__;
    VED_PAGER[string ('c')]            = &__change__;
    VED_PAGER[string ('r')]            = &__change_chr__;
    VED_PAGER[string ('~')]            = &__toggle_case__;
    VED_PAGER[string ('J')]            = &__join_line__;
    VED_PAGER[string ('d')]            = &__del__;
    VED_PAGER[string ('D')]            = &__del_to_end__;
    VED_PAGER[string ('x')]            = &__del_chr__;
    VED_PAGER[string ('X')]            = &__del_chr__;
    VED_PAGER[string ('>')]            = &__indent_out__;
    VED_PAGER[string ('<')]            = &__indent_in__;
    VED_PAGER[string (Input->rmap.delete[0])]    = &__del_chr__;
    VED_PAGER[string (Input->rmap.backspace[0])] = &__del_trail_ws__;
    VED_PAGER[string (Input->rmap.backspace[1])] = &__del_trail_ws__;
    VED_PAGER[string (Input->rmap.backspace[2])] = &__del_trail_ws__;

    ifnot (NULL == Env->DISPLAY)
      ifnot (NULL == Env->XAUTHORITY)
        ifnot (NULL == Sys->XCLIP_BIN)
          Load.file (Env->STD_LIB_PATH + "/X/seltoX", NULL);
  end

  beg
    new_wind ();
  end
end
