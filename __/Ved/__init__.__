class Ved
  typedef Ftype
    _i,_ii,_len,_chr,_type,_fname,_abspath,_fd,_flags,_maxlen,_indent,
    _linlen,_avail_rows,_findex,_index,_shiftwidth,_expandtab,
    _autoindent, _dir, _autochdir,
    ptr, rows, cols, clrs, lins, lnrs, vlins, lines,
    st_, comment_str, comment_out_ref,
    vedloop, vedloopcallback,
    ved, set,
    draw, lexicalhl, autoindent, pairs,
    is_pager,
    opt_show_tilda, opt_show_status_line,
    __NOR__,
    __VAR__,
  end

  typedef Insert
    chr,
    lnr,
    prev_l,
    next_l,
    modified,
  end

  typedef Pos
    _i,
    _index,
    _findex,
    ptr,
  end

  typedef Wind
    cur_frame,
    frame_rows,
    frame_names,
    frames,
    buffers,
    bufnames,
    rline,
    name,
    dir,
    prev_buf_ind,
    setframesize,
  end

  let VED_DIR = Env->TMP_PATH + "/ved/" + string (Env->PID);
  let EL_MAP  = [902, [904:906], 908, [910:929], [931:937], [945:974]];
  let EN_MAP  = [['a':'z'], ['A':'Z']];
  let MAPS    = [EL_MAP, EN_MAP];
  let WCHARS  = array_map (String_Type, &char, [10, ['0':'9'], EN_MAP, EL_MAP, '_']);
  let DEFINED_UPPER_CASE = ['+', ',', '}', ')', ':', '>'];
  let DEFINED_LOWER_CASE = ['-', '.', '{', '(', ';', '<'];

  var public DIGRAPHS = [
    167,   % paragraph §
    8220,  % “
    8212,  % —
    8304,  % ⁰
    8230,  % …
    729,   % ˙ 
    [8308:8319], % ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽ ⁾ ⁿ
    10003, % correct ✓
    176,   % °
    171,   % « 
    187,   % »
    215,   % ×
    247,   % ÷
    185,   % power of one ¹
    178,   % power of two ²
    179,   % power of three ³
    [188:190], % ¼ ½ ¾
    [8531:8542],  % one third ⅓ etc ...
    183,   % multiplication dot ·
    8771,  % short of... ≃
    [9833:9835], % music notes
    [9837:9839], % likewise
    169,  % ©
    174,  % ®
    8364, % €
    ];
  var public MARKS        = Assoc_Type[Struct_Type];
  var public VED_WIND     = Assoc_Type[Wind_Type];
  var public FTYPES       = Assoc_Type[Struct_Type];
  var public REG          = Assoc_Type[String_Type];
  var public VED_CUR_WIND = NULL;
  var public VED_PREV_WIND = NULL;
  var public UNDELETABLE  = String_Type[0];
  var public SPECIAL      = String_Type[0];
  var public VED_ROWS     = [1:LINES - 3];
  var public VED_MODIFIED       = 0x01;
  var public VED_ONDISKMODIFIED = 0x02;
  var public VED_RDONLY         = 0x04;
  var public VED_ISONLYPAGER    = 0;
  var public VED_RLINE          = 1;
  var public SEARCH_HISTFILE    = Env->USER_DATA_PATH + "/.__" + Env->USER + "_ved_search_history";
  var public SEARCH_HISTINDEX   = NULL;
  var public SEARCH_HISTORY     = {};
  var public VED_OPTS = struct
    {
    del_frame = 1,
    new_frame = 1,
    def_ftype = "txt",
    force,
    };

  var VED_INFOCLRFG = Smg->COLOR.infofg;
  var VED_INFOCLRBG = Smg->COLOR.infobg;
  var VED_PROMPTCLR = Smg->COLOR.prompt;

  def __invalid__ (s) proc
  end

  var public VED_PAGER = Assoc_Type[Ref_Type, &__invalid__];
  var public VEDCOUNT;

  def set_ftype (name, dir, type)
    variable t = assoc_key_exists (FTYPES, name)
      ? FTYPES[name]
      : struct {dir, type};

    ifnot (NULL == dir)
      t.dir = dir;

    ifnot (NULL == type)
      t.type = type;
    else
      t.type = @Ftype_Type;

    FTYPES[name] = t;
  end

  def build_ftype_table () proc
    variable i, ii, ft, dir;
    variable nss = [Env->USER_DATA_PATH, Env->STD_DATA_PATH];

    _for i (0, length (nss) - 1)
      {
      ft = listdir (nss[i] + "/ftypes");
      if (NULL == ft)
        continue;

      _for ii (0, length (ft) - 1)
        if (Dir.isdirectory ((dir = nss[i] + "/ftypes/" + ft[ii], dir)))
          set_ftype (NULL, ft[ii], dir, NULL);
      }
  end

  beg
    build_ftype_table ();

    if (-1 == Dir.make_parents (VED_DIR, File->PERM["PRIVATE"]))
      throw ClassError, "Ved::ATINIT::" + VED_DIR + ": cannot make directory, "
        + errno_string (errno);
  end

  def getXsel () public proc
    "";
  end

  decl public seltoX, seltoXClipboard
  decl public  __console, __vline, __vfind_word
  decl get_cur_buf, __ins_digraph__

  def __topline (str) public proc
    variable d = NULL == This.request.debug
      ? ""
      : "depth [" + string (_stkdepth) + "] ";

    variable t = sprintf ("%sPID[%d] [%s] (W %s) [%s]",
      d, getpid, This.is.me, VED_CUR_WIND,
        strftime ("%a %d %I:%M:%S"));

    @str = "(" + This.cur["mode"] + ") " + @str;
    @str += repeat (" ", COLUMNS - strlen (@str) - strlen (t)) + t;
  end

  def topline () public proc
    variable str = qualifier ("str", "");
    __topline (&str);
    Smg.atrcaddnstr (str, [2, 1][getuid () == 0], 0, 0, COLUMNS);
  end

  def toplinedr () public proc
    variable str = qualifier ("str", "");
    __topline (&str);
    Smg.atrcaddnstrdr (str, [2, 1][getuid () == 0], 0, 0, qualifier ("row", PROMPTROW),
      qualifier ("col", Ved.get_cur_rline ()._col), COLUMNS);
  end

  subclass Reg from Ved

  def toogle_infoclrbg ()
    if (VED_INFOCLRBG == Smg->NOCOLOR)
      VED_INFOCLRBG = Smg->COLOR.infobg;
    else
      VED_INFOCLRBG = Smg->NOCOLOR;
  end

  def toogle_infoclrfg ()
    if (VED_INFOCLRFG == Smg->NOCOLOR)
      VED_INFOCLRFG = Smg->COLOR.infofg;
    else
      VED_INFOCLRFG = Smg->NOCOLOR;
  end

  def __define_case__ (chr) proc
    ifnot (any (@chr == [DEFINED_LOWER_CASE, DEFINED_UPPER_CASE]))
      return 0;

    variable low = 1;
    variable ind = wherefirst_eq (DEFINED_LOWER_CASE, @chr);
    if (NULL == ind)
      {
      ind = wherefirst_eq (DEFINED_UPPER_CASE, @chr);
      low = 0;
      }

    @chr = low ? DEFINED_UPPER_CASE[ind] : DEFINED_LOWER_CASE[ind];

    1;
  end

  def __indent_In__ (s, line, i_) proc
    ifnot (strlen (line) - s._indent)
      return NULL;

    ifnot (isblank (line[s._indent]))
      return NULL;

    while (isblank (line[@i_]) && @i_ < s._shiftwidth + s._indent)
      @i_++;

    substr (line, @i_ + 1 - s._indent, -1);
  end

  def __vdebug (s, msg) public proc
    ifnot (qualifier_exists ("dont_write_to_stderr"))
      IO.tostderr (msg);

    ifnot (qualifier_exists ("dont_send_message"))
      if (NULL == s)
        Smg.send_msg_dr (msg, 1, NULL, NULL);
      else
        Smg.send_msg_dr (msg, 1, s.ptr[0], s.ptr[1]);

    if (qualifier_exists ("hold"))
      () = Input.getch ();

    ifnot (qualifier_exists ("handler"))
      return;

    variable f = qualifier ("handler");
    if (NULL == f || 0 == (typeof (f) == Ref_Type) || 0 == __is_callable (f))
      return;

    (@f) (s, msg;;__qualifiers);
  end

  def __vdef_ved (s, fname) public proc
    ifnot (qualifier_exists ("dont_set"))
      s.set (fname, VED_ROWS, NULL;;__qualifiers);

    Ved.setbuf (s._abspath;;__qualifiers);

    Ved.write_prompt (" ", 0);

    s.draw (;;__qualifiers);

    Ved.preloop (s);

    toplinedr;

    s.vedloop ();
  end

  def __vsystem () public proc
    (@__get_reference ("__system")) (;;__qualifiers);
  end

  def __vset_col__ (s, linlen, dir) proc
    if ('+' == dir)
      if (s.ptr[1] + 1 < linlen - s._indent)
        ifnot (s.ptr[1] + 1 == s._indent + s._linlen) % -> cells/context
          s.ptr[1]++;
  end

  def __vset_col_at_end__ (s, linlen) proc
    if (linlen <= s._linlen)
      s.ptr[1] = s._indent + linlen;
    else
      s.ptr[1] = s._indent + s._maxlen; % handle case when maxlen + indent > virtual cols
  end

  def __vis_wrapped__ (s, linlen, index, findex) proc
    variable vlen = s._maxlen - s._indent;
    if (linlen <= vlen)
      return 0;

    ifnot (NULL == index)
      if (index >= vlen)
        return 1;

    ifnot (NULL == findex)
      if (findex - s._indent)
        return 1;

    0;
  end

%%%% end

  % -1 = abort, 1 = need refresh, 0 = nothing
  def __vleft__ (s, is_wrap) proc
    ifnot (s.ptr[1] - s._indent)
      ifnot (is_wrap)
        return -1;

    s._index--;

    if (is_wrap)
      ifnot (s.ptr[1] - s._indent)
        {
        s._findex--;
        return 1;
        }

    s.ptr[1]--;

    0;
  end

  def __vright__ (s, linlen) proc
    if (s._index - s._indent == linlen - 1 || 0 == linlen)
      return -1;

    if (s.ptr[1] < s._maxlen - s._indent - 1)
      {
      s.ptr[1]++;
      s._index++;
      return 0;
      }

    s._index++;
    s._findex++;

    1;
  end

  def __vadjust_col__ (s, linlen, plinlen) proc
    if (linlen == 0 || 0 == s.ptr[1] - s._indent)
      {
      s.ptr[1] = s._indent;
      s._findex = s._indent;
      s._index = s._indent;
      }
    else if (linlen > s._linlen && s.ptr[1] + 1 == s._maxlen ||
      (s.ptr[1] - s._indent == plinlen - 1 && linlen > s._linlen))
        {
        s.ptr[1] = s._maxlen - 1;
        s._findex = s._indent;
        s._index = s._linlen - 1 + s._indent;
        }
    else if ((0 != plinlen && s.ptr[1] - s._indent == plinlen - 1 && (
        linlen < s.ptr[1] || linlen < s._linlen))
       || (s.ptr[1] - s._indent && s.ptr[1] - s._indent >= linlen) ||
         (__vis_wrapped__ (s, plinlen, s._index, s._findex)))
        {
        s.ptr[1] = linlen - 1 + s._indent;
        s._index = linlen - 1 + s._indent;
        s._findex = s._indent;
        }
  end

  def set_modified (s) public proc
    s._flags |= VED_MODIFIED;
  end

  def get_ftype_name (fn)
    variable ftype = qualifier ("ftype");
    variable ext;

    if (NULL == ftype)
      if (NULL == fn)
        ftype = VED_OPTS.def_ftype;
      else
        {
        ext = strtrim_beg (path_extname (fn), ".");
        ifnot (strlen (ext))
          ftype = VED_OPTS.def_ftype;
        else
          ftype = ext;
        }

    ifnot (any (assoc_get_keys (FTYPES) == ftype))
      if ("mutt-" == substr (path_basename (fn), 1, 5))
        ftype = "mail";
      else if ("h" == ftype)
        ftype = "c";
      else if ("sl" == ftype)
        ftype = "__";
      else
        ftype = VED_OPTS.def_ftype;

    ftype;
  end

  def! init_ftype (ftype)
    variable types = assoc_get_keys (FTYPES);
    variable exists = NULL;
    if (NULL == ftype || NULL == (exists = wherefirst
        (ftype == types), exists))
      (ftype = VED_OPTS.def_ftype, exists = 1);

    variable type;
    variable dir = NULL;

    ifnot (NULL == exists)
      {
      type = FTYPES[ftype];
      ifnot (NULL == type.type._type)
        return @type.type;
      else
        (dir = type.dir, type = @type.type);
      }
    else
      type = @Ftype_Type;

    variable f;

    ifnot (NULL == dir)
      f = dir + "/" + ftype + "_functions";
    else
      {
      f = (dir = Env->USER_DATA_PATH + "/ftypes/" + ftype, dir + "/" +
        ftype + "_functions");

      if (-1 == access (f + ".slc", F_OK))
        f = (dir = Env->STD_DATA_PATH + "/ftypes/" + ftype, dir + "/" +
           ftype + "_functions");
      }

    % allow the exception, 
    Load.file (f, NULL); % that merely means a generous fatal
                         % on any error
    type._type = ftype;
    type.set = __get_reference (ftype + "_settype");
    if (NULL == type.set)
      %fatal
      throw ClassError, "Fatal: " + ftype + "_settype (), missing function declaration";

    self.set_ftype (type._type, dir, type);
    type;
  end

  def __get_null_str (indent) proc
    sprintf ("%s\000", repeat (" ", indent));
  end

  def __write_line (fp, line, indent) proc
    line = substr (line, indent + 1, -1);
    return fwrite (line, fp);
  end

  def __vgetlinestr (s, line, ind) public proc
    substr (line, ind + s._indent, s._linlen);
  end

  def __vwritetofile (file, lines, indent, bts) public proc
    variable i, retval,
      append = (NULL == (append = qualifier ("append", 0), append)
       ? 0
       : append),
      fp = fopen (file, ["w", "a+"][append > 0]);

    if (NULL == fp) % fopen sets errno
      return errno;

    _for i (0, length (lines) - 1)
      if (-1 == (retval = __write_line (fp, lines[i] + "\n", indent), retval))
        return errno;
      else
        @bts += retval;

    if (-1 == fclose (fp))
      return errno;

    0;
  end

  def __vinitrowsbuffvars__ (s) proc
    s.cols = Integer_Type[length (s.rows)];
    s.cols[*] = 0;

    s.clrs = Integer_Type[length (s.rows)];
    s.clrs[*] = 0;
    s.clrs[-1] = VED_INFOCLRFG;

    s._avail_rows = length (s.rows) - 2;
  end

  def __vaddbuf__ (s) proc
    ifnot (access (s._fname, F_OK))
      ifnot (path_is_absolute (s._fname))
        s._abspath = realpath (getcwd () + s._fname);
      else
        s._abspath = realpath (s._fname);
    else % bug on the application logic
      ifnot (path_is_absolute (s._fname))  % cannot be stored as unique
        s._abspath = getcwd () + s._fname;
      else
        s._abspath = s._fname;

    variable w = qualifier ("wind", Ved.get_cur_wind ());

    if (any (s._abspath == w.bufnames))
      return w.buffers[s._abspath];

    w.bufnames = [w.bufnames,  s._abspath];
    w.buffers[s._abspath] = s;
    w.buffers[s._abspath]._dir = qualifier ("_dir",
      realpath (path_dirname (s._abspath)));

    w.buffers[s._abspath];
  end

  def waddlineat (s, line, clr, row, col, len) proc
    Smg.atrcaddnstr (line, clr, row, col, len);
    s.lexicalhl ([line], [row]);
  end

  def waddline (s, line, clr, row) proc
    Smg.atrcaddnstr (line, clr, row, s._indent, s._linlen);
    s.lexicalhl ([line], [row]);
  end

  def __set_status_line_clr__ (s, clr, set) proc
    s.clrs[-1] = clr;
    Smg->IMG[s.rows[-1]][1] = clr;
    if (set)
      (@[Smg.hlregion, Smg.hlregiondr]
        [qualifier_exists ("draw_status_line")])
          (Smg, clr, s.rows[-1], 0, 1, COLUMNS);
  end

  def __vset_status_line_fg_clr (s, set) public proc
    __set_status_line_clr__ (s, VED_INFOCLRFG, set);
  end

  def __vset_status_line_bg_clr (s, set) public proc
    __set_status_line_clr__ (s, VED_INFOCLRBG, set);
  end

  def __vunset_status_line_clr (s, set) public proc
    __set_status_line_clr__ (s, Smg->NOCOLOR, set);
  end

  def framesize (frames) proc
    variable f = Integer_Type[frames];
    variable ff = Array_Type[frames];
    variable len = length (VED_ROWS);

    f[*] = len / frames;
    f[0] += len mod frames;

    variable i, iend, istart = 0;

    _for i (0, length (f) - 1)
      {
      iend = istart + f[i] - 1;
      ff[i] = VED_ROWS[[istart:iend]];
      istart = iend + 1;
      }

    ff;
  end

  def __cline__ (s) proc
    This.cur["mode"] = "command";
    topline;
    variable rl = Ved.get_cur_rline ();
    Rline.set (rl);
    Rline.readline (rl;ved = s,
      draw = (@__get_reference ("SCRATCH")) != s._abspath);

    if ('!' == Ved.get_cur_rline ().argv[0][0] &&
        (@__get_reference ("SCRATCH")) == s._abspath)
      {
      (@__get_reference ("__draw_buf")) (s;_i = s._ii);
      return -1;
      }

    This.cur["mode"] = "pager";

    topline;
    s = get_cur_buf (NULL);

    ifnot (NULL == Smg->__IMG)
      {
      Smg->IMG = Smg->__IMG;
      (@__get_reference ("__draw_buf")) (s;_i = s._ii);
      Smg->__IMG = NULL;
      }

    Smg.setrcdr (s.ptr[0], s.ptr[1]);

    0;
  end

  def _vedloopcallback_ (s) proc
    variable retval = (@s.__NOR__["beg"][string (s._chr)]) (s);
    if (-1 == retval)
      return;

    ifnot (retval)
      (@VED_PAGER[string (s._chr)]) (s;;__qualifiers);

    () = (@s.__NOR__["end"][string (s._chr)]) (s);
  end

  def __check_msg__ (s) proc
    if (1 == Smg->MSG_SEND)
       Smg->MSG_SEND++;
    else if (2 == Smg->MSG_SEND)
      {
      Smg.send_msg_dr (" ", 0, s.ptr[0], s.ptr[1]);
      Smg->MSG_SEND = 0;
      }
  end

  def _loop_ (s) proc
    __check_msg__ (s);

    forever
      {
      s = get_cur_buf (NULL);
      VEDCOUNT = -1;
      s._chr = Input.getch (;
        disable_langchange, expr_fun = &__ins_digraph__, expr_args = s);

      if ('1' <= s._chr <= '9')
        {
        VEDCOUNT = "";

        while ('0' <= s._chr <= '9')
          {
          VEDCOUNT += char (s._chr);
          s._chr = Input.getch (;disable_langchange);
          }

        try
          VEDCOUNT = integer (VEDCOUNT);
        catch SyntaxError:
          {
          Smg.send_msg_dr ("count: too many digits >= " +
            string (256 * 256 * 256 * 128), 1, s.ptr[0], s.ptr[1]);
          continue;
          }
        }

      % here is an issue, if a callback function creates a nested loop 
      %
      % try to avoid that, either with a control variable or in this
      % case of 'q',
      % try to minimize overhead which is unvoidable, by escaping quickly
      % with the common condition
      ifnot ('q' == s._chr)
        s.vedloopcallback (;;__qualifiers);
      else
        if (qualifier_exists ("unhandled"))
          s.vedloopcallback (;;__qualifiers);

      __check_msg__ (get_cur_buf (NULL));

      if (':' == s._chr && (VED_RLINE || 0 == VED_ISONLYPAGER))
        if (__cline__ (s))
          continue;

      if ('q' == s._chr && (VED_ISONLYPAGER || s.is_pager))
        return 1;
      }

    0;
  end

  def _handle_quit_ (s) proc
    variable w = Ved.get_cur_wind ();
    variable bnms = Ved.get_bufnames (w);

    if (1 < w.frames && length (bnms))
      {
      __vdel_frame (s);
      return;
      }

    variable ref = __get_reference ("ved_quit");

    if (NULL == ref)
      return;

    (@ref) ("quit");
    % user canselled decision (trouble)
    % for now let it go, it might be handled,
    % or it will quit if we've been out of a loop,
    % in that case the cansellation is canseled
  end

  def _vedloop_ (s) proc
    if (_loop_ (s;;__qualifiers) == 1)
      _handle_quit_ (s);

    ifnot (s.opt_show_status_line)
      __vunset_status_line_clr (s, 1);
  end

  def autoindent (s, indent, line) proc
    % lookup for a (not private) type_autoindent
    variable f = __get_reference (s._type + "_autoindent");
    % call it (if exists) and calc the value
    if (NULL == f)
    % else calculate the value as:
      @indent =  s._indent + (s._autoindent ? s._shiftwidth : 0);
    else
      @indent = (@f) (s, line;;__qualifiers);
  end

  def lexicalhl (s, lines, vlines) proc
  end

  def _on_lang_change_ (ptr) proc
    topline;
    Smg.setrcdr (ptr[0], ptr[1]);
  end

  def __on_keypress__ (s) proc
    0;
  end

  def __init_fun_norm__ () proc
    Assoc.new (Assoc_Type, ["beg", "end"],
      [Assoc.new (Ref_Type, NULL, NULL;default = &__on_keypress__),
       Assoc.new (Ref_Type, NULL, NULL;default = &__on_keypress__)]);
  end

  def __init_fun_all__ (s) proc
    if (NULL == s.__NOR__)
      s.__NOR__ = __init_fun_norm__ (;;__qualifiers);
  end

  def __init_var__ () proc
    Assoc.new (Any_Type, NULL, NULL);
  end

%%% ___v

  def __vlinlen (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    strlen (s.lins[r]) - s._indent;
  end

  def __vline (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    s.lins[r];
  end

  def __vlnr (s, r) public proc
    r = (r == '.' ? s.ptr[0] : r) - s.rows[0];
    s.lnrs[r];
  end

  def __vdraw_tail (s) public proc
    variable linlen = __vlinlen (s, '.');

    if (linlen > s._linlen && s._findex < linlen - s._linlen)
      Smg.hlregion (2, s.ptr[0], s._indent + s._linlen - 2, 1, 2);

    Smg.atrcaddnstrdr (Ved.tail (s;;struct {@__qualifiers (), linlen = linlen}),
      [Smg->NOCOLOR, VED_INFOCLRFG][s.opt_show_status_line > 0],
      s.rows[-1], 0, s.ptr[0], s.ptr[1], COLUMNS);
  end

  def _draw_ (s) proc
    if (0 > s._len) % this shouldn't never occur (simple means that
      {             % something went wrong and needs fixing at the cause)
      __vdebug (s, "_draw_ (), caught unacceptable s._len condition, " +
         s._fname;hold);
      s.lins = [__get_null_str (s._indent)];
      s.lnrs = [0];
      s._ii = 0;

      Smg.aratrcaddnstrdr ([repeat (" ", COLUMNS), Ved.vtail (s)],
        [0, s.opt_show_status_line ? VED_INFOCLRFG : Smg->NOCOLOR],
        [s.rows[0], s.rows[-1]], [0, 0], s.rows[0], 0, COLUMNS);

      return;
      }

    s.lnrs = Integer_Type[0];
    s.lins = String_Type[0];

    variable
      i = s.rows[0],
      ar = String_Type[0];

    s._ii = s._i;

    while (s._i <= s._len && i <= s.rows[-2])
      {
      s.lnrs = [s.lnrs, s._i];
      s.lins = [s.lins, s.lines[s._i]];
      s._i++;
      i++;
      }

    s.vlins = [s.rows[0]:s.rows[0] + length (s.lins) - 1];

    s._i = s._i - (i) + s.rows[0];

    if (-1 == s._i)
      s._i = 0;

    if (s.ptr[0] >= i)
      s.ptr[0] = i - 1;

    ar = array_map (String_Type, &substr, s.lins, 1, s._maxlen);

    variable indices = [0:length (ar) - 1];
    variable clrs = @s.clrs;
    variable arlen = length (ar);
    variable rowslen = length (s.rows);

    if (arlen < rowslen - 1)
      {
      ifnot (s._type == "ashell")
        clrs[[arlen:length (clrs) - 2]] = 5;

      variable t = String_Type[rowslen - arlen - 1];
      t[*] = s.opt_show_tilda ? "~" : " ";
      ar = [ar, t];
      }

    ar = [ar, Ved.tail (s;;__qualifiers ())];

    ifnot (s.opt_show_status_line)
      clrs[-1] = Smg->NOCOLOR;

    Smg.set_img (s.rows, ar, clrs, s.cols);

    Smg.aratrcaddnstr (ar, clrs, s.rows, s.cols, COLUMNS);

    s.lexicalhl (ar[indices], s.vlins);

    (@[Smg.setrcdr, Smg.setrc][qualifier_exists ("dont_draw")]) (Smg, s.ptr[0], s.ptr[1]);
  end

  def __vgetstatus (s) proc
    s.st_ = stat_file (s._abspath);

    if (NULL == s.st_)
      s.st_ = struct
        {
        st_atime,
        st_mtime,
        st_uid = getuid (),
        st_gid = getgid (),
        st_size = 0
        };
  end

  include self from Ved as Ved

  def __vfpart_of_word (s, line, col, start) proc
    ifnot (strlen (line))
      return "";

    variable origcol = col;

    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent &&
        any (WCHARS == substr (line, col + 1, 1)));

      @start = col + 1;
      }

    substr (line, @start + 1, origcol - @start + 1);
  end

  def __vfind_word (s, line, col, start, end) public proc
    if (0 == strlen (line) || ' ' == line[col] ||
        0 == any (WCHARS == char (line[col])))
      return "";

    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent &&
        any (WCHARS == substr (line, col + 1, 1)));

      @start = col + 1;
      }

    variable len = strlen (line);

    while (col++, col < len && any (WCHARS == substr (line, col + 1, 1)));

    @end = col - 1;

    substr (line, @start + 1, @end - @start + 1);
  end

  def __vfind_Word (s, line, col, start, end) proc
    ifnot (col - s._indent)
      @start = s._indent;
    else
      {
      while (col--, col >= s._indent && 0 == isblank (substr (line, col + 1, 1)));

      @start = col + 1;
      }

    variable len = strlen (line);

    while (col++, col < len && 0 == isblank (substr (line, col + 1, 1)));

    @end = col - 1;

    substr (line, @start + 1, @end - @start + 1);
  end

  def __get_dec (chr, dir) proc
    any ([['0':'9'], '.'] == chr);
  end

  def __get_hex (chr, dir) proc
    any (chr == ("lhs" == dir ? ['0'] : [['0':'9'], ['a':'f'], ['A':'F'], 'x']));
  end

  def __vfind_nr (indent, line, col, start, end, ishex, isoct, isbin) proc
    ifnot (any ([['0':'9'], '-', '.', 'x'] == line[col]))
      return "";

    variable mbishex = 0;
    variable getfunc = [&__get_dec, &__get_hex];

    @ishex = 'x' == line[col];
    getfunc = getfunc[@ishex];

    ifnot (col - indent)
      @start = indent;
    else
      {
      ifnot (line[col] == '-')
        while (col--, col >= indent && (@getfunc) (line[col], "lhs"));

      @start = col + 1;

      if (col)
        if (line[col] == '-')
          @start--;
        else if (line[col] == 'x') % maybe is hex
          mbishex = 1; % when at least one digit found, and 'x' is not the char 
      }                % where the matching stopped. the string under the cursor
                       % can form a valid hex number
    variable len = strlen (line);

    while (col++, col < len && (@getfunc) (line[col], "rhs"));

    @end = col - 1;

    variable nr = substr (line, @start + 1, @end - @start + 1);

    if (nr == "-" || nr == "." || nr[0] == '.' || 0 == strlen (nr))
      return "";

    if (1 == strlen (nr))
      if ('0' == nr[0])
        if (col < len)
          ifnot (@ishex)
            if ('x' == line[col])
              mbishex = 1;

    % hex incr/decr is done when cursor is on an 'x'
    if (mbishex)  % for now and for both conditions and for safety, refuse
      return "";  % to modify the string, if an 'x' is found on the string

    len = strlen (nr);
    col = 0;

    ifnot (len mod 4)
      while (col++, col < len && (@isbin = any (['0','1'] == nr[col]), @isbin));

    col = 0;

    if (1 < len && 0 == @isbin)
      if ('0' == nr[0])
        while (col++, col < len && (@isoct = any (['0':'7'] == nr[col]), @isoct));

    if (nr[-1] == '.')
      if (len > 1)
        {
        nr = substr (nr, 1, len - 1);
        @end--;
        }
      else
        return "";

    if (@ishex || @isoct || @isbin)
      try
        return string (integer (sprintf ("%s%s", @isbin ? "0b" : "", nr)));
      catch SyntaxError:
        return "";

    nr;
  end

  def on_wind_change (w) public proc
    topline;
    Ved.setbuf (w.frame_names[w.cur_frame]);
  end

  def get_wind_name ()
    VED_CUR_WIND;
  end

  def get_wind_names ()
    variable winds = assoc_get_keys (VED_WIND);
    winds[array_sort (winds)];
  end

  def wind_change (to)
    variable winds = get_wind_names (NULL);

    variable w;
    variable i;
    variable windlen = length (winds);

    if (Integer_Type == typeof (to))
      if (windlen - 1 < to)
        return;
      else
        w = winds[to];
    else
      ifnot (any ([",", ".", "prev"] == to))
        return;
      else
        if (to == ",")
          w = winds[wherefirst (winds == VED_CUR_WIND) - 1];
        else if (to == ".")
          {
          i = wherefirst (winds == VED_CUR_WIND);
          i = i == windlen - 1 ? 0 : i + 1;
          w = winds[i];
          }
        else
          w = VED_PREV_WIND;

    if (NULL == w || w == VED_CUR_WIND || all (0 == (winds == w)))
      return;

    VED_PREV_WIND = VED_CUR_WIND;
    VED_CUR_WIND = w;

    w = VED_WIND[w];

    on_wind_change (w);

    Ved.draw_wind (;;__qualifiers);
  end

  def on_wind_new (w) public proc
    (@__get_reference ("__initrline"));
  end

  def wind_init (name, frames) public proc
    if (any (name == assoc_get_keys (VED_WIND))
        && 0 == qualifier_exists ("force"))
      return;

    variable setframesize = __get_qualifier_as (Ref_Type, qualifier ("framesize_fun"),
        This.framesize);

    if (NULL == setframesize)
      setframesize = &framesize;

    VED_WIND[name] = @Wind_Type;
    VED_WIND[name].name = name;
    VED_WIND[name].frames = frames > This.has.max_frames
      ? This.has.max_frames
      : frames < 1
        ? 1
        : frames;
    VED_WIND[name].frame_names = String_Type[VED_WIND[name].frames];
    VED_WIND[name].frame_rows = (@setframesize) (VED_WIND[name].frames);
    VED_WIND[name].cur_frame = 0;
    VED_WIND[name].buffers = Assoc_Type[Ftype_Type];
    VED_WIND[name].bufnames = String_Type[0];
    VED_WIND[name].prev_buf_ind = -1;
    VED_WIND[name].setframesize = setframesize;

    if (qualifier_exists ("on_wind_new"))
      on_wind_new (VED_WIND[name];;__qualifiers);
  end

  def new_wind () proc
    variable name = _NARGS ? () : qualifier ("wind_name");
    variable i;
    variable winds = assoc_get_keys (VED_WIND);
    variable frames = __get_qualifier_as (Integer_Type,
      qualifier ("frames"), This.has.frames);

    if (NULL == frames)
      frames = 1;

    if (any (name == winds))
      return;

    if (NULL == name)
      _for i ('a', 'z')
        {
        name = char (i);
        ifnot (any (name == winds))
          break;

        if ('z' == i)
          return;
        }

    ifnot (qualifier_exists ("in_bg"))
      {
      VED_PREV_WIND = VED_CUR_WIND;
      VED_CUR_WIND = name;
      }

    wind_init (name, frames;;__qualifiers ());

    if (qualifier_exists ("draw_wind"))
      Ved.draw_wind ();
  end

  def get_bufnames (w)
    if (NULL == w)
      w = get_cur_wind (NULL);

    if (qualifier_exists ("dont_filter"))
      return w.bufnames;

    variable i, bnames = @w.bufnames;
    _for i (0, length (bnames) - 1)
      if (any (bnames[i] == SPECIAL))
        bnames[i] = NULL;

    bnames[wherenot (_isnull (bnames))];
  end

  def bufdelete (s, bufname, force) public proc
    if (any (bufname == UNDELETABLE))
      return;

    variable w = Ved.get_cur_wind ();
    variable bnames = get_bufnames (NULL, w);

    ifnot (any (bufname == bnames))
      return;

    if (s._flags & VED_MODIFIED && force)
      {
      variable bts = 0;
      variable retval = __vwritetofile (bufname, s.lines, s._indent, &bts);
      ifnot (0 == retval)
        {
        Smg.send_msg_dr (errno_string (retval), 1, NULL, NULL);
        return;
        }
      }

    variable isatframe = wherefirst (w.frame_names == bufname);
    variable iscur = Ved.get_cur_bufname () == bufname;

    assoc_delete_key (w.buffers, bufname);

    variable i = wherefirst (bufname == w.bufnames);
    Array.delete_at (&w.bufnames, i);

    variable winds = assoc_get_keys (VED_WIND);

    ifnot (length (bnames) - 1)
      ifnot (1 == length (winds))
        {
        assoc_delete_key (VED_WIND, VED_CUR_WIND);
        winds = assoc_get_keys (VED_WIND);
        VED_CUR_WIND = winds[0];
        w = Ved.get_cur_wind ();
        s = get_cur_buf (NULL);
        Ved.setbuf (s._abspath);
        Ved.draw_wind ();
        return;
        }

    ifnot (NULL == isatframe)
      if (1 < w.frames)
        Ved.del_frame (isatframe);

    if (iscur)
      if (1 == length (bnames))
        {
        Smg.send_msg_dr ("There is no normal buffer loaded, press q to exit",
          1, NULL, NULL);

        if ('q' == Input.getch ())
          This.exit (0);
        }

    i = i ? i - 1 : length (w.bufnames) - 1;

    Ved.setbuf (w.bufnames[i]);

    s = get_cur_buf (NULL);
    s.draw ();
  end

  subclass Mark from Ved

  beg
    MARKS[string ('`')] = struct {pos = @Pos_Type, linlen};
  end

  def preloop (s)
    Ved.Mark.backtick (s);
  end

  def __hl_groups (s, lines, vlines, colors, regexps) public proc
    variable
      i,
      ii,
      col,
      subs,
      match,
      color,
      regexp,
      line,
      iscomment = 0,
      context;

    _for i (0, length (lines) - 1)
      {
      line = lines[i];
      if (0 == strlen (line) || "\000" == line)
        continue;

      iscomment = anynot (array_map (Integer_Type, &strncmp,
        strtrim_beg (line), s.comment_str, strlen (s.comment_str)));

      _for ii (0, length (regexps) - 1)
        {
        color = colors[ii];
        regexp = regexps[ii];
        col = 0;

        if (ii && iscomment)
          break;

          %!  invalid index - check arrays for NULL
        while (subs = pcre_exec (regexp, line, col), subs > 1)
          {
          match = pcre_nth_match (regexp, 1);
          % revailed by (see) diff.syntax
          % maybe add a check for NULL
          % my opinion is that the check hides the code mistake
          % somewhere in the pattern related code, independently
          % of the designed highlighting implementation (which in that
          % state needs improvement),the code should provide expected
          % results, (assuming the toolchain has no weakness, (which in that
          % case it has (and I have to find why (and I'm boring for that
          % kind of thing (...
          col = match[0];
          context = match[1] - col;
          %% subs > 1 (in that case four),
          % but match is NULL (though changing from
          % 1 (the first submatch) to either the rest of the three succeeds,
          % so we end up with an invalid index
          %.
          Smg.hlregion (color, vlines[i], col, 1, context);
          col += context;
          }

        ifnot (ii)
          if (col)                  % + 1 is to avoid the error pattern
            line = substr (line, 1, match[0] + 1); % to match it as eol
        }
      }
  end

  def __vreread (s) public proc
    s.lines = Ved.getlines (s._abspath, s._indent, s.st_);

    s._len = length (s.lines) - 1;

    ifnot (s._len)
      {
      s._ii = 0;
      s.ptr[0] = s.rows[0];
      }
    else if (s._ii < s._len)
      while (s.ptr[0] - s.rows[0] + s._ii > s._len)
        s.ptr[0]--;
    else
      {
      while (s._ii > s._len)
        s._ii--;

      s.ptr[0] = s.rows[0];
      }

    s.ptr[1] = 0;

    s._i = s._ii;

    __vgetstatus (s);

    s.draw ();
  end

  def __vchange_frame (s) public proc
    s = Ved.change_frame (;;__qualifiers);
  end

  def __vnew_frame (s) public proc
    ifnot (VED_OPTS.new_frame)
      return;

    s = Ved.new_frame (VED_DIR + "/" + string (_time) + ".noname";
      _autochdir = 0, _dir = get_cur_buf (NULL)._dir);
  end

  def __vdel_frame (s) public proc
    ifnot (VED_OPTS.del_frame)
      return;

    Ved.del_frame ();
    s = Ved.get_cur_buf ();
  end

  def __del_wind__ (s) proc
    ifnot (This.has.new_windows)
      return;

    Ved.del_wind (VED_CUR_WIND);
    s = get_cur_buf (NULL);
  end

  def on_wind_new (w) public proc
    variable
      fn,
      is_special = [1, 0][qualifier_exists ("file")];

    if (is_special)
      fn = VED_DIR + "/" + string (_time) + ".noname.txt";
    else
      fn = qualifier ("file");

    variable s = Ved.init_ftype (get_ftype_name (NULL, fn;;__qualifiers)
      ;;__qualifiers);

    s.set (fn, w.frame_rows[0], NULL;_autochdir = 0);

    Ved.setbuf (s._abspath;;__qualifiers);

    if (is_special)
      SPECIAL = [SPECIAL, fn];

    (@__get_reference ("__initrline"));

    Ved.draw_wind ();
  end

  def __new_wind__ (s) proc
    ifnot (This.has.new_windows)
      return;

    new_wind (;;struct {@__qualifiers, on_wind_new});
    s = get_cur_buf (NULL);
  end

  def __goto_wind__ (s, chr) proc
    ifnot (This.has.new_windows)
      return;

    if (any (['0':'9'] == chr))
      chr = int (chr - '0');
    else
      chr = char (chr);

    wind_change (NULL, chr);
    s = get_cur_buf (NULL);
  end

  def __vhandle_CTRL_w (s) public proc
    variable chr = qualifier ("input_char");
    if (NULL == chr)
      chr = Input.getch ();

    variable keys = [
      'w', 's', 'd', 'k', 'n', ',', '.',
      Input->UP, Input->CTRL_w, Input->DOWN, ['0':'9']];

    ifnot (any (chr == keys))
      return;

    if (any (['w', Input->CTRL_w, Input->DOWN] == chr))
      {
      __vchange_frame (s;dir = "next");
      return;
      }

    if (any ([Input->UP] == chr))
      {
      __vchange_frame (s;dir = "prev");
      return;
      }

    if ('s' == chr)
      {
      __vnew_frame (s);
      return;
      }

    if ('d' == chr)
      {
      __vdel_frame (s);
      return;
      }

    if ('k' == chr)
      {
      __del_wind__ (s);
      return;
      }

    if ('n' == chr)
      {
      __new_wind__ (s);
      return;
      }

    if (any ([['0':'9'], ',', '.'] == chr))
      {
      __goto_wind__ (s, chr);
      return;
      }
  end

  def __pg_on_carriage_return (s) public proc
    Ved.Ed.editline (s;exec_func = '\r');
  end

  def __write_on_esc__ (s) proc
    Ved.writefile (s, NULL, s.ptr, NULL, NULL;send_msg);
  end

  def __vslang_load (lines) public proc
    variable ns = qualifier ("ns", "Global");

    lines[0] = strtrim_beg (lines[0]);

    ifnot (strncmp (lines[0], "ns:", 3))
      {
      variable t = strtrim_beg (substr (lines[0], 4, -1));
      ifnot (strlen (t))
        lines[0] = "";
      else
        {
        ns = strtok (t)[0];
        lines[0] = substr (t, strlen (ns) + 1, -1);
        }
      }

    try
      {
      __eval (strjoin (lines, "\n"), ns);
      }
    catch AnyError:
      {
      Exc.print (NULL);
      (@__get_reference ("__messages"));
      }
  end

  def __on_escape__ (s) proc
    variable names = ["commandline", "write", "substitute",
      "eval", "system"];
    variable help = [
        "to command line",
        "write current buffer",
        "make substitutions (for current line)",
        "evaluate current line",
        "send current line to system ()"];

    variable action = Rline.get_selection (names, help, s.ptr);

    ifnot (strlen (action))
      return;

    switch (action)
      {
      case "write":
        __write_on_esc__ (s);
      }

      {
      case "commandline":
        () = __cline__ (s);
      }

      {
      case "system":
        __vsystem ([strtrim_beg (__vline (s, '.'), "!")]);
      }

      {
      case "eval":
        __vslang_load ([__vline (s, '.')]);
      }

      {
      case "substitute":
        variable rl = Ved.get_cur_rline ();
        variable argv = ["substitute", "--dont-ask-when-subst",
          "--global", "--range=.", "--pat="];

        Rline.set (rl;line = strjoin (argv, " "), argv = argv,
          col = int (sum (strlen (argv))) + length (argv),
          ind = length (argv) - 1);

        Rline.readline (rl);
      }

    s.draw ();
  end

  def _set_nr_ (s, incrordecr) proc
    variable
      count = qualifier ("count", 1),
      end,
      start,
      nr,
      col = s._index,
      i = __vlnr (s, '.'),
      line = __vline (s, '.');

    variable ishex = 0;
    variable isoct = 0;
    variable isbin = 0;

    nr = __vfind_nr (s._indent, line, col, &start, &end, &ishex, &isoct, &isbin);

        ifnot (strlen (nr))
    if (qualifier_exists ("abort"))
      return -1;
    else
      {
      nr = String.decode (line)[col];

      if ("+" == incrordecr)
        nr += count;
      else if ("-" == incrordecr)
        nr -= count;

      if (any (nr ==  [[0:31], ['~' + 1:160]]))
        return -1;

      line = sprintf ("%s%c%s", substr (line, 1, col), nr,
        substr (line, col + 2, -1));

      s.lins[s.ptr[0] - s.rows[0]] = line;
      s.lines[i] = line;
      set_modified (s);

      s.st_.st_size = Array.String.__len (s.lines, s._len);

      waddline (s, line, 0, s.ptr[0]);

      __vdraw_tail (s);
      return 0;
      }

    variable isdbl = _slang_guess_type (nr) == Double_Type;
    variable convf = [&atoi, &atof][isdbl];

    if ("+" == incrordecr)
      nr = (@convf) (nr) + count;
    else if ("-" == incrordecr)
      nr = (@convf) (nr) - count;
    else if ("*" == incrordecr)
      nr = (@convf) (nr) * count;
    else if ("//" == incrordecr)
      nr = (@convf) (nr) / count;

    variable format = sprintf ("%s%%%s",
      ishex ? "0x0" : isoct ? "0" : "",
      ishex ? "x" : isoct ? "o" : isbin ? "B" : isdbl ? ".3f" : "d");

    nr = sprintf (format, nr);

    if (isbin)
      while (strlen (nr) mod 4)
        nr = "0" + nr;

    line = sprintf ("%s%s%s", substr (line, 1, start), nr, substr (line, end + 2, -1));

    s.lins[s.ptr[0] - s.rows[0]] = line;
    s.lines[i] = line;
    s.ptr[1] = start;
    s._index = start;

    set_modified (s);

    s.st_.st_size = Array.String.__len (s.lines, s._len);

    waddline (s, line, 0, s.ptr[0]);

    __vdraw_tail (s);
    0;
  end

  def __incr_nr__ (s) proc
    () = _set_nr_ (s, "+";count = VEDCOUNT == -1 ? 1 : VEDCOUNT);
  end

  def __decr_nr__ (s) proc
    () = _set_nr_ (s, "-";count = VEDCOUNT == -1 ? 1 : VEDCOUNT);
  end

  def __undo__ (s) proc
    Ved.Vundo.undo (s);
  end

  def __redo__ (s) proc
    Ved.Vundo.redo (s);
  end

  subclass Pager from Ved
  subclass Search from Ved
  subclass Ed from Ved
  subclass Insert from Ved
  subclass Vundo from Ved
  subclass Visual from Ved

  beg
    ifnot (This.system."supports?"["hunspell"])
      public variable Spell = struct {Hunspell = struct
        {new = funref (`loop (_NARGS) pop; NULL;`)}};
    else
      Class.load ("Spell");
  end

  subclass Lingual from Ved

  def __vhandle_word__ (s) proc
    variable names = ["translate", "clipboard", "xa_clipboard",
      "register_word", "register_WORD", "spell"];
    variable help =  [
        "translate current word",
        "send word to xa_primary",
        "send word to xa_clipboard",
        "put the word in the standard register",
        "put the WORD in the standard register",
        "spell word"];
    variable action = Rline.get_selection (names, help, s.ptr);

    ifnot (strlen (action))
      return;

    variable
      start,
      end,
      col = s._index,
      line = __vline (s, '.'),
      word = (any (["translate", "spell", "register_word"] == action))
        ? __vfind_word (s, line, col, &start, &end)
        : __vfind_Word (s, line, col, &start, &end);

    ifnot (strlen (word))
      return;

    switch (action)
      {
      case "translate":
        Ved.Lingual.translate (s;word = word);

        s.draw ();
      }

      {
      case "spell":
        variable sp = Ved.Lingual.spell (word);
        ifnot (length (sp))
          return;

        sp = strjoin (sp[0], " ");
        if (sp == word)
          return;

        Ved.Ed.change_word (s, 'w';with_word = sp);
      }

      {
      case "clipboard" || case "xa_clipboard":

        if ("clipboard" == action)
          seltoX (word);
        else
          seltoXClipboard (word);
      }

      {
      case "register_word" || case "register_WORD":
        Ved.Reg.set ("\"", word;msg = "yanked word and ");
      }
  end

  def init_search_hist () proc
    variable ar = NULL;
    ifnot (access (SEARCH_HISTFILE, F_OK|R_OK))
      ar = File.readlines (SEARCH_HISTFILE);
    if (NULL != ar && length (ar))
      {
      array_map (&list_append, SEARCH_HISTORY, ar);
      SEARCH_HISTINDEX = 0;
      }
  end

  beg
    init_search_hist ();
  end

  def __Yank__ (s) proc
    variable
      reg = qualifier ("reg", "\""),
      line = __vline (s, '.');

    Ved.Reg.set (reg, line + "\n";msg = "yanked line and ");
    seltoX (line + "\n");
  end

  def __register__ (s) proc
    variable reg = Input.getch ();
    ifnot (any (VedReg->REGS == reg))
      return;

    reg = char (reg);

    variable chr = Input.getch ();
    ifnot (any (['D', 'c', 'd', 'Y', 'p', 'P', 'x', 'X', Input->rmap.delete]
      == chr))
      return;

    if (any (['x', 'X', Input->rmap.delete] == chr))
      Ved.Ed.del_chr (s;reg = reg, chr = chr);
    else if ('Y' == chr)
      __Yank__ (s;reg = reg);
    else if ('d' == chr)
      Ved.Ed.del (s;reg = reg);
    else if ('c' == chr)
      Ved.Ed_change (s;reg = reg);
    else if ('D' == chr)
      Ved.Ed.del_to_end (s;reg = reg);
    else if ('P' == chr)
      Ved.Ed.Put (s;reg = reg, _chr = 'P');
    else
      Ved.Ed.Put (s;reg = reg, _chr = 'p');
  end

  def __askonsubst__ (s, fn, lnr, fpart, context, lpart, replace) proc
    variable cmp_lnrs = Integer_Type[0];
    variable ar =
      ["@" + fn + " linenr: " + string (lnr+1),
       "replace?",
       Smg.__HLINE__ (),
       sprintf ("%s%s%s", fpart, context, lpart),
       Smg.__HLINE__ (),
       "with?",
       Smg.__HLINE__ (),
       sprintf ("%s%s%s", fpart, replace, lpart),
       Smg.__HLINE__ (),
       "y[es]/n[o]/q[uit]/a[ll]/c[ansel]"];

    variable hl_reg = Array_Type[2];
    hl_reg[0] = [5, PROMPTROW - 8, strlen (fpart), 1, strlen (context)];
    hl_reg[1] = [2, PROMPTROW - 4, strlen (fpart), 1, strlen (replace)];

    variable char_ar =  ['y', 'n', 'q', 'a', 'c'];
    Smg.askprintstr (ar, char_ar, &cmp_lnrs;hl_region = hl_reg);
  end

  def __filter_global__ (buf, pat, lnrs, whenmatch) proc
    if (NULL == pat)
      return (lnrs[*] = 1, lnrs);

    variable lnr, line, len, i;
    variable __pcre_exec = fun (`(pat, line)
    try
      {
      pcre_exec (pat, line, 0);
      }
    catch AnyError:
      {
      Exc.print (NULL);
      0;
      }
    `);

    variable llnrs = Integer_Type[length (lnrs)];

    _for i (0, length (lnrs) -1)
      {
      lnr = lnrs[i];
      line = buf.lines[lnr];
      if (__pcre_exec.call (pat, line))
        ifnot (whenmatch)
          continue;
        else
          llnrs[i] = 1;
      else
        ifnot (whenmatch)
          llnrs[i] = 1;
      }

    llnrs;
  end

  def __delete__ (buf, lnrs) proc
    buf.lines[where (lnrs)] = NULL;
    variable len, nulllines = _isnull (buf.lines);

    len = buf._len - length (nulllines);

    buf.lines = buf.lines[wherenot (nulllines)];
    buf._len = length (buf.lines) - 1;

    buf._i = buf._ii - len;
    if (0 > buf._i)
      buf._i = 0;

    buf._index = buf._indent;
    buf._findex = buf._indent;
    buf.ptr[0] = buf.rows[0];
    buf.ptr[1] = buf._indent;

    if (-1 == buf._len)
      {
      buf.lines = [__get_null_str (buf._indent)];
      buf._len = 0;
      buf._i = 0;
      }

    buf.st_.st_size = Array.String.__len (buf.lines, buf._len + 1);
    set_modified (buf);
    buf.draw ();
  end

  def __system__ (buf, lnrs) proc
    variable lines = buf.lines[where (lnrs)];
    __vsystem (array_map (String_Type, &strtrim_beg, lines, "!"));
  end

  def __eval__ (buf, lnrs) proc
    __vslang_load (buf.lines[where (lnrs)]);
  end

  def __write__ (buf, lnrs) proc
    Smg.atrceraseeol (PROMPTROW, 0);
    variable fn = "", r;
    variable rl = Ved.get_cur_rline ();
    Rline.set (rl;col = 0, row = PROMPTROW);

    forever
      {
      r = Rline.fnamecmpToprow (rl, &fn;
        header = "filename to write selected lines, >> at the end to append");
      variable len = strlen (fn);
      if (033 == r || 0 == len)
        return;

      if (r)
        break;

      fn = Rline.getline (;line = fn, col = strlen (fn), argv = [fn]);
      len = strlen (fn);
      break;
      }

    variable append = 0;
    if (2 < len)
      if (">>" == substr (fn, len - 1, -1))
        {
        append = 1;
        fn = strtrim (substr (fn, 1, len - 2));
        }

    ifnot (access (fn, F_OK))
      ifnot (append)
        if ('n' == IO.ask ([fn + ": exists, overwrite? y/n"], ['y', 'n']))
          return;

    Ved.writefile (buf, 1, buf.ptr, fn, append;
      lines = buf.lines[where (lnrs)]);
  end

  def __global () public proc
    variable global = 0,
             whenmatch = 1,
             ask = 1,
             pat = NULL,
             action = NULL,
             ind, range = NULL;
    variable args = __pop_list (_NARGS);
    variable buf = get_cur_buf (NULL);
    variable lnrs = [0:buf._len];
    variable acts = ["write", "delete", "eval", "system"];

    args = list_to_array (args, String_Type);

    pat = Opt.Arg.getlong_val ("pat", NULL, &args;del_arg);
    action = Opt.Arg.getlong_val ("action", NULL, &args;del_arg);
    whenmatch = NULL == Opt.Arg.exists ("--whenNotMatch", &args;del_arg);

    if (NULL == action || 0 == strlen (action) || 0 == any (action == acts))
      {
      Smg.send_msg_dr ("--action= argument is required, supported are [" +
        strjoin (acts, ", ") + "]", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    if (NULL == (lnrs = Opt.Arg.getlong_val ("range", "range", &args;fun_args =
        {buf, lnrs}, del_arg, defval = lnrs), lnrs))
      return;

    ifnot (NULL == pat)
    if (NULL == (pat = Re.compile (pat), pat))
      {
      Smg.send_msg_dr ("Error while compiling pattern", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    variable llnrs = __filter_global__ (buf, pat, lnrs, whenmatch);
    (@[&__write__, &__delete__, &__eval__, &__system__][wherefirst (action == acts)])
      (buf, llnrs);
  end

  def get_digraph ()
    variable
      charar = array_map (String_Type, &string, DIGRAPHS),
      len = length (charar),
      help = array_map (String_Type, &sprintf, ": %2c  |", DIGRAPHS);

    ifnot (qualifier_exists ("just_digraphs"))
      {
      variable
        ext = ["%", "*", "=", "^W"],
        ext_help = ["cbuf|", "xsel|", "eval|", "Cword|"];

      charar = [charar, ext];
      help = [help, ext_help];
      }

    variable d = Rline.get_selection (charar, help, qualifier ("ptr");;
      struct {@__qualifiers, format = 1, literal});

    ifnot (strlen (d))
      return 0;

    variable idx = wherefirst (d == charar);
    if (NULL == idx)
      return 0;

    if (idx < len)
      return DIGRAPHS[idx];

    Ved.Reg.get (ext[idx-len]);
    1;
  end

  def get_expression () public proc
     Ved.get_digraph (;;__qualifiers);
  end

  def __spell (argv) public proc
    variable buf = get_cur_buf (NULL);
    variable lines = Ved.Lingual.spell (buf.lines);
    variable len = length (lines);

    if (0 == len || len - 1 != buf._len)
      return;

    buf.lines = __tmp (lines);
    buf.st_.st_size = Array.String.__len (buf.lines, buf._len + 1);

    set_modified (buf);
    buf.draw ();
  end

  def __substitute () public proc
    variable global = 0, ask = 1, pat = NULL, sub = NULL, range = NULL;
    variable args = __pop_list (_NARGS);
    variable buf = get_cur_buf (NULL);
    variable lnrs = [0:buf._len];

    args = list_to_array (args, String_Type);

    pat = Opt.Arg.getlong_val ("pat", NULL, &args;del_arg, ret_arg);
    sub = Opt.Arg.getlong_val ("sub", NULL, &args;
      "defval on no value" = "", del_arg, ret_arg);

    if (NULL == pat || NULL == sub || anynot (strlen ([pat])))
      {
      Smg.send_msg_dr ("--pat= and --sub= are required", 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    global = (NULL != Opt.Arg.exists ("--global", &args;del_arg));
    ask = (NULL == Opt.Arg.exists ("--dont-ask-when-subst", &args;del_arg));

    if (NULL == (lnrs = Opt.Arg.getlong_val ("range", "range", &args;fun_args =
       {buf, lnrs}, del_arg, defval = lnrs), lnrs))
      {
      Smg.send_msg_dr (Opt.err (), 1, buf.ptr[0], buf.ptr[1]);
      return;
      }

    variable s = Subst.new (pat, sub;
      fname = buf._abspath, global = global, askwhensubst = ask,
      askonsubst = &__askonsubst__);

    if (NULL == s)
      {
      IO.tostderr (Subst.err ());
      return;
      }

    variable retval = Subst.exec (s, buf.lines[lnrs]);

    ifnot (retval)
      {
      Ved.Vundo.set (buf, buf.lines[s.indices], s.indices);

      variable ar = ();

      ifnot (length (ar) == length (lnrs))
        {
        ifnot (lnrs[0])
          ifnot (lnrs[-1] == buf._len)
            buf.lines = [ar, buf.lines[[lnrs[-1] + 1:]]];
          else
            buf.lines = ar;
        else
          ifnot (lnrs[-1] == buf._len)
            buf.lines = [buf.lines[[:lnrs[0] - 1]], ar, buf.lines[[lnrs[-1] + 1:]]];
          else
            buf.lines = [buf.lines[[:lnrs[0] - 1]], ar];

        buf._len = length (buf.lines) - 1;
        }
      else
        buf.lines[lnrs] = ar;

      buf.st_.st_size = Array.String.__len (buf.lines, buf._len + 1);

      set_modified (buf);
      buf.draw ();
      }
  end

  def PROJECT_VED (argv) public proc
    ifnot (length (argv) - 1)
      return;

    variable pj;
    variable fn;
    variable args = argv[[1:]];

    variable ind = Opt.Arg.compare ("--from-file=", &args);
    ifnot (NULL == ind)
      {
      fn = strchop (args[ind], '=', 0);
      if (1 == length (fn))
        return;

      fn = fn[1];

      if (-1 == access (fn, F_OK|R_OK))
        return;

      variable ar = File.readlines (fn);

      pj = strtok (ar[0]);
      }
    else
      pj = args;

    if (length (pj) + length (assoc_get_keys (VED_WIND)) > 10)
      return;

    variable wc = VED_CUR_WIND, i, w = NULL, j, found,
      nwns,owns = assoc_get_keys (VED_WIND);

    variable checked = qualifier_exists ("checked");

    _for i (0, length (pj) - 1)
      {
      fn = pj[i];
      ifnot (checked)
        {
        variable retval = Ved.checkfile (fn);

        ifnot (any ([1, -1] == retval))
          {
          variable buf = Ved.get_cur_buf ();
          variable err = Ved.err ();
          Smg.send_msg_dr (err, 1, buf.ptr[0], buf.ptr[1]);
          IO.tostderr (err);
          ifnot (0 == retval)
            continue;
          }
        }

      new_wind (;on_wind_new);

      nwns = assoc_get_keys (VED_WIND);

      if (length (nwns) == length (owns))
        continue;

      _for j (0, length (nwns) - 1)
        if (any (nwns[j] == owns))
          continue;
        else
          {
          w = nwns[j];
          break;
          }

      owns = @nwns;

      variable cw, ft, s;
      cw = Ved.get_cur_wind ();
      ft = Ved.get_ftype_name (fn;;__qualifiers);
      s = Ved.init_ftype (ft;;__qualifiers);
      s.set (fn, cw.frame_rows[Ved.get_cur_frame ()], NULL;;__qualifiers);
      Ved.setbuf (s._abspath;;__qualifiers);
      }

    if (NULL == w)
      return;

    variable ws = Ved.get_wind_names ();
    if (NULL == wc || all (0 == (wc == ws)))
      _for i (0, length (ws) - 1)
        ifnot (ws[i] == w)
          {
          wc = ws[i];
          break;
          }

    VED_PREV_WIND = wc;
    VED_CUR_WIND = w;

    Ved.draw_wind ();
  end

  def __gotomark__ (s) proc
    Ved.Mark.goto (s);
  end

  def __mark__ (s) proc
    Ved.Mark.set (s);
  end

  def __indent_in__ (s) proc
    Ved.Ed.indent_in (s);
  end

  def __indent_out__ (s) proc
    Ved.Ed.indent_out (s);
  end

  def __join_line__ (s) proc
    Ved.Ed.join_line (s);
  end

  def __del_to_end__ (s) proc
    Ved.Ed.del_to_end (s);
  end

  def __change_chr__ (s) proc
    Ved.Ed.change_chr (s);
  end

  def __del_trail_ws__ (s) proc
    Ved.Ed.del_trail_c (s, " ");
  end

  def __del_trail_c__ (s) proc
    Ved.Ed.del_trail_c (s, NULL);
  end

  def __del_chr__ (s) proc
    Ved.Ed.del_chr (s);
  end

  def __toggle_case__ (s) proc
    Ved.Ed.toggle_case (s);
  end

  def __del__ (s) proc
    Ved.Ed.del (s);
  end

  def __change__ (s) proc
    Ved.Ed.change (s);
  end

  def __put__ (s) proc
    Ved.Ed.Put (s);
  end

  def __Put__ (s) proc
    Ved.Ed.Put (s);
  end

  def __ins_digraph__ (s) proc
    variable d = get_digraph (NULL);
    ifnot (d)
      return;

    if (1 < d)
      {
      Ved.Ed.Put (s;buf = char (d));
      return;
      }

    variable buf = ();
    if (NULL == buf)
      return;

    Ved.Ed.Put (s;buf = buf);
  end

  def __newline__ (s) proc
    Ved.Ed.newline (s;;__qualifiers);
  end

  def __editline__ (s) proc
    Ved.Ed.editline (s);
  end

  def __search__ (s) proc
    if (Input->BSLASH == s._chr && VEDCOUNT > 0)
      ifnot (_set_nr_ (s, "//"; abort, count = VEDCOUNT))
        return;

    Ved.Search.run (s;;__qualifiers);
  end

  def __search_word__ (s) proc
    if ('*' == s._chr && VEDCOUNT > 0)
      ifnot (_set_nr_ (s, "*"; abort, count = VEDCOUNT))
        return;

    Ved.Search.word (s);
  end

  def __search_last__ (s) proc
    Ved.Search.last (s);
  end

  def __visual__ (s) proc
    Ved.Visual.mode (s);
  end

  def __vhandle_comma (s) public proc
    variable chr = Input.getch ();

    ifnot (any (['p'] == chr))
      return;

    if ('p' == chr)
      {
      seltoX (s._abspath);
      Smg.send_msg_dr (s._abspath, 1, s.ptr[0], s.ptr[1]);
      }
  end

  def __space__ (s) proc
    ifnot (s.st_.st_size)
      return;

    variable lnr = __vlnr (s, '.');
    s.lines[lnr] = substr (s.lines[lnr], 1, s._index) + " " +
        substr (s.lines[lnr], s._index + 1, -1);

    s.st_.st_size ++;

    set_modified (s);

    s.draw ();
  end

  def __up__ (s) proc
    Ved.Pager.up (s);
  end

  def __down__ (s) proc
    Ved.Pager.down (s);
  end

  def __left__ (s) proc
    Ved.Pager.left (s);
  end

  def __right__ (s) proc
    Ved.Pager.right (s);
  end

  def __bol__ (s) proc
    Ved.Pager.bol (s);
  end

  def __bof__ (s) proc
    Ved.Pager.bof (s);
  end

  def __eol__ (s) proc
    Ved.Pager.eol (s);
  end

  def __eos__ (s) proc
    Ved.Pager.eos (s);
  end

  def __eof__ (s) proc
    Ved.Pager.eof (s);
  end

  def __bolnblnk__ (s) proc
    Ved.Pager.bolnblnk (s);
  end

  def __g__ (s) proc
    Ved.Pager.g (s);
  end

  def __gotoline__ (s) proc
    Ved.Pager.gotoline (s);
  end

  def __word_change_case__ (s) proc
    Ved.Pager.word_change_case (s);
  end

  def __end_word__ (s) proc
    Ved.Pager.end_word (s);
  end

  def __page_up__ (s) proc
    Ved.Pager.page_up (s);
  end

  def __page_down__ (s) proc
    Ved.Pager.page_down (s);
  end

  def __app_detach__ (s) proc
    App.detach (;;__qualifiers);
  end

  def __app_new__ (s) proc
    if (s._chr == Input->F2)
      (@__get_reference ("_->app_new")) (Ved.get_cur_rline ()
        ;;__qualifiers);
    else
      (@__get_reference ("_->app_new")) (Ved.get_cur_rline ()
        ;;struct {@__qualifiers, issu = 1});
  end

  def __app_rec__ (s) proc
    if (s._chr == Input->F1)
      (@__get_reference ("_->app_reconnect")) (Ved.get_cur_rline ()
        ;;struct {@__qualifiers, previous});
    else
      (@__get_reference ("_->app_reconnect")) (Ved.get_cur_rline ()
        ;;__qualifiers);
  end

  def __child_rec__ (s) proc
    (@__get_reference ("App->child_reconnect")) (Ved.get_cur_rline ()
      ;;__qualifiers);
  end

  def __wind_menu__ (s) proc
    (@__get_reference ("wind_mang")) (Ved.get_cur_rline ()
      ;;__qualifiers);
  end

  def __app_menu__ (s) proc
    (@__get_reference ("App->app_menu")) (Ved.get_cur_rline ()
      ;;__qualifiers);
  end

  def __ved_funcs (a) public proc
    a["__diff"] = @Argvlist_Type;
    a["__diff"].func = fun (`
        (argv)
      variable
        d,
        ved = @Ved.get_cur_buf ();

      if (NULL == (d = Ved.unified_diff (ved), d) ||
          0 == strlen (d))
        return;

      __viewfile  (DIFF_VED, "diff", [1, 0], 0);
      Ved.setbuf (ved._abspath);
      Ved.draw_wind (;reread = 0);
    `).__funcref;
  end

  def __wind_rout__ (s, dir) proc
    ifnot (This.has.new_windows)
      return;

    if (1 == length (VED_WIND))
      {
      if (Rline_Type == typeof (s))
        __new_wind__ (NULL);
      else
        __new_wind__ (s);

      return;
      }

    wind_change (NULL, dir;;__qualifiers);
  end

  def __vwind_next (s) public proc
    __wind_rout__ (s, "."; reread = (0 == This.is.ved));
  end

  def __vwind_prev (s) public proc
    __wind_rout__ (s, "prev";reread = (0 == This.is.ved));
  end

  def __vwind_new () public proc
    ifnot (This.has.new_windows)
      return;

    new_wind (;;(0 == qualifier_exists ("with_no_callbacks")
      ? struct {@__qualifiers, on_wind_new}
      : __qualifiers));
  end

  def init ()
    VED_PAGER[string (Input->F1)]      = &__app_rec__;
    VED_PAGER[string (Input->F2)]      = &__app_rec__;
    VED_PAGER[string (Input->F3)]      = &__app_new__;
    VED_PAGER[string (Input->F4)]      = &__app_menu__;
    VED_PAGER[string (Input->F5)]      = &__wind_menu__;
    VED_PAGER[string (Input->F6)]      = &__vwind_next;
    VED_PAGER[string (Input->F8)]      = &__vwind_prev;
    VED_PAGER[string (Input->F12)]     = &paste_xsel;
    VED_PAGER[string (Input->UP)]      = &__up__;
    VED_PAGER[string (Input->DOWN)]    = &__down__;
    VED_PAGER[string (Input->HOME)]    = &__bof__;
    VED_PAGER[string (Input->NPAGE)]   = &__page_down__;
    VED_PAGER[string (Input->PPAGE)]   = &__page_up__;
    VED_PAGER[string (Input->RIGHT)]   = &__right__;
    VED_PAGER[string (Input->LEFT)]    = &__left__;
    VED_PAGER[string (Input->END)]     = &__eol__;
    VED_PAGER[string (Input->DETACH)]  = &__app_detach__;
    VED_PAGER[string (Input->BSLASH)]  = &__search__;
    VED_PAGER[string (Input->QMARK)]   = &__search__;
    VED_PAGER[string (Input->CTRL_a)]  = &__incr_nr__;
    VED_PAGER[string (Input->CTRL_b)]  = &__page_up__;
    VED_PAGER[string (Input->CTRL_f)]  = &__page_down__;
    VED_PAGER[string (Input->CTRL_l)]  = &__vreread;
    VED_PAGER[string (Input->CTRL_n)]  = &__newline__;
    VED_PAGER[string (Input->CTRL_p)]  = &__newline__;
    VED_PAGER[string (Input->CTRL_r)]  = &__redo__;
    VED_PAGER[string (Input->CTRL_w)]  = &__vhandle_CTRL_w;
    VED_PAGER[string (Input->CTRL_v)]  = &__visual__;
    VED_PAGER[string (Input->CTRL_x)]  = &__decr_nr__;
    VED_PAGER[string (033)]            = &__on_escape__;
    VED_PAGER[string (',')]            = &__vhandle_comma;
    VED_PAGER[string ('"')]            = &__register__;
    VED_PAGER[string ('#')]            = &__search_word__;
    VED_PAGER[string ('*')]            = &__search_word__;
    VED_PAGER[string ('n')]            = &__search_last__;
    VED_PAGER[string ('N')]            = &__search_last__;
    VED_PAGER[string ('W')]            = &__vhandle_word__;
    VED_PAGER[string ('\t')]           = &pag_completion;
    VED_PAGER[string ('\r')]           = &__pg_on_carriage_return;
    VED_PAGER[string ('`')]            = &__gotomark__;
    VED_PAGER[string ('Y')]            = &__Yank__;
    VED_PAGER[string ('j')]            = &__down__;
    VED_PAGER[string ('k')]            = &__up__;
    VED_PAGER[string ('G')]            = &__eof__;
    VED_PAGER[string ('g')]            = &__g__;
    VED_PAGER[string (' ')]            = &__space__;
    VED_PAGER[string ('e')]            = &__end_word__;
    VED_PAGER[string ('l')]            = &__right__;
    VED_PAGER[string ('h')]            = &__left__;
    VED_PAGER[string ('-')]            = &__eos__;
    VED_PAGER[string ('$')]            = &__eol__;
    VED_PAGER[string ('^')]            = &__bolnblnk__;
    VED_PAGER[string ('0')]            = &__bol__;
    VED_PAGER[string ('u')]            = &__undo__;
    VED_PAGER[string ('v')]            = &__visual__;
    VED_PAGER[string ('V')]            = &__visual__;
    VED_PAGER[string ('m')]            = &__mark__;
    VED_PAGER[string ('C')]            = &__editline__;
    VED_PAGER[string ('i')]            = &__editline__;
    VED_PAGER[string ('a')]            = &__editline__;
    VED_PAGER[string ('A')]            = &__editline__;
    VED_PAGER[string ('o')]            = &__newline__;
    VED_PAGER[string ('O')]            = &__newline__;
    VED_PAGER[string ('P')]            = &__Put__;
    VED_PAGER[string ('p')]            = &__put__;
    VED_PAGER[string ('c')]            = &__change__;
    VED_PAGER[string ('r')]            = &__change_chr__;
    VED_PAGER[string ('~')]            = &__toggle_case__;
    VED_PAGER[string ('J')]            = &__join_line__;
    VED_PAGER[string ('d')]            = &__del__;
    VED_PAGER[string ('D')]            = &__del_to_end__;
    VED_PAGER[string ('x')]            = &__del_chr__;
    VED_PAGER[string ('X')]            = &__del_chr__;
    VED_PAGER[string ('>')]            = &__indent_out__;
    VED_PAGER[string ('<')]            = &__indent_in__;
    VED_PAGER[string (Input->rmap.delete[0])]    = &__del_chr__;
    VED_PAGER[string (Input->rmap.backspace[0])] = &__del_trail_ws__;
    VED_PAGER[string (Input->rmap.backspace[1])] = &__del_trail_c__;
    VED_PAGER[string (Input->rmap.backspace[2])] = &__del_trail_c__;

    __vwind_new (;;__qualifiers);
  end
end
