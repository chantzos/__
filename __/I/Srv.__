subclass Srv
  __init__
    init
    app_at_exit
    mainloop
    appnew
    appreconnect
    idle
    reconnect_to_app
    connect_to_app
  end

  var SRV_FIFO    = NULL;
  var SRV_FIFO_FD = NULL;

  var CONNECTED_APPS = String_Type[0];
  var CONNECTED_PIDS = Integer_Type[0];

  var CHILDREN      = Assoc_Type[Assoc_Type];
  var CHILDREN_CON  = String_Type[0];
  var CHILDREN_PIDS = Integer_Type[0];
  var CHILD_CUR     = NULL;

  var __APP__  = NULL;
  var CUR_APP  = This.is.my.name + "::" + string (Env->PID);
  var PREV_APP = NULL;

  def idle ()
    if (length (CONNECTED_APPS))
      {
      variable ret = IO.ask (["There are idled applications", "Do you really want to exit?",
        "y/n"], ['y', 'n']);
      if ('n' == ret)
        {
        variable rl = Ved.get_cur_rline ();
        Rline.prompt (rl, rl._lin, rl._col);
        return 0;
        }
      }

    exit_me (0);
  end

  def init ()
    SRV_FIFO = This.is.my.tmpdir + "/Session.fifo";
    ifnot (access (SRV_FIFO, F_OK|R_OK))
      if (File.istype (stat_file (SRV_FIFO).st_mode, "fifo"))
        () = remove (SRV_FIFO);

    if (-1 == mkfifo (SRV_FIFO, 0755))
      throw ClassError, "Srv::init::" + SRV_FIFO + " cannot create fifo, " +
        errno_string (errno);
  end

  def app_at_exit (s)
    variable code = waitpid (s.pid, 0);

    variable idx = wherefirst_eq (CONNECTED_PIDS, s.pid);

    CONNECTED_PIDS[idx] = 0;
    CONNECTED_APPS[idx] = NULL;
    CONNECTED_PIDS = CONNECTED_PIDS[where (CONNECTED_PIDS)];
    CONNECTED_APPS = CONNECTED_APPS[wherenot (_isnull (CONNECTED_APPS))];

    () = close (s.fd);
    () = remove (s.fifo);
    assoc_delete_key (App->APPS[s.name], string (s.pid));

    variable name = s.name + "::" + string (s.pid);
    if (name == CUR_APP)
      CUR_APP = NULL;

    if (name == PREV_APP)
      PREV_APP = NULL;
  end

  var screen_size_changed = 0;

  decl __sigwinch_handler__
  def __sigwinch_handler__ (sig) proc
    screen_size_changed = 1;
    signal (SIGWINCH, &__sigwinch_handler__);
  end

  def __exit_rout__ (s, handl) proc
    Api.restore_app (;sigint = This.has.sigint ? handl : NULL);
    signal (SIGWINCH, This.on.sigwinch);
    if (screen_size_changed)
      (@This.on.sigwinch) (SIGWINCH);

    ifnot (NULL == CUR_APP)
      {
      PREV_APP = CUR_APP;
      CUR_APP = This.is.my.name + "::" + string (Env->PID);
      }
    else
      {
      CUR_APP = This.is.my.name + "::" + string (Env->PID);
      variable idx;
      if (length (CONNECTED_APPS))
        _for idx (0, length (CONNECTED_APPS) - 1)
          ifnot (CONNECTED_APPS[idx] + "::" + string (CONNECTED_PIDS[idx])
             == CUR_APP)
            {
            PREV_APP = CONNECTED_APPS[idx] + "::" + string (CONNECTED_PIDS[idx]);
            break;
            }

      }

    if (0 == qualifier_exists ("mode") ||
        0 == (qualifier ("mode") == "Insert"))
      {
      Rline.set (s);
      Rline.prompt (s, s._lin, s._col);
      }
  end

  def appnew (s)
    ifnot (This.has.other_apps)
      return;

    variable retval, issu;
    variable apps = assoc_get_keys (App->APPS);

    ifnot (qualifier_exists ("no_menu"))
      {
      Rline.set (s);
      Rline.prompt (s, s._lin, s._col);

      variable saved = Input->rmap.right;
      Input->rmap.right = [saved, Input->rmap.app_new];
      () = Rline.commandcmp (s, apps;already_filtered);
      Input->rmap.right = saved;
      }

    ifnot (any (apps == s.argv[0]))
      return;

    if (This.has.sigint)
      {
      variable handl;
      signal (SIGINT, SIG_IGN, &handl);
      }

    screen_size_changed = 0;
    signal (SIGWINCH, &__sigwinch_handler__);

    loop (1)
    {
    self.connect_to_app (s.argv[0];;__qualifiers);

    if (APP_ERR)
      break;

    forever
      {
      __APP__ = CUR_APP;
      retval = self.mainloop (&issu);
      if (Api->APP_RECON_OTH == retval)
        {
        retval = self.reconnect_to_app (__APP__);
        if (1 == retval)
          break 2;
        }
      else if (Api->APP_RECON_PREV == retval)
        {
        retval = self.reconnect_to_app (PREV_APP);
        if (1 == retval)
          break 2;
        }
      else if (Api->APP_CON_NEW == retval)
        {
        self.connect_to_app (__APP__;issu = issu);
        if (APP_ERR)
          break 2;
        }
      else
        break 2;
      }
    }

    __exit_rout__ (s, handl;;__qualifiers);
  end

  def get_connected_apps () proc
    [This.is.my.name + "::" + string (Env->PID), array_map (
      String_Type, &sprintf, "%s::%d", CONNECTED_APPS, CONNECTED_PIDS)];
  end

  def appreconnect (s)
    ifnot (This.has.other_apps)
      return;

    loop (1) {
    variable apps;
    if (qualifier_exists ("previous"))
      ifnot (NULL == PREV_APP)
        ifnot (CUR_APP == PREV_APP)
          {
          apps = [PREV_APP];
          s.argv[0] = PREV_APP;
          break;
          }

    apps = get_connected_apps ()[[1:]];

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    variable saved = Input->rmap.right;
    Input->rmap.right = [saved, Input->rmap.app_prev, Input->rmap.app_rec];
    () = Rline.commandcmp (s, apps;already_filtered);
    Input->rmap.right = saved;

    variable handl;
    }

    if (any (apps == s.argv[0]))
      {
      if (s.argv[0] == This.is.my.name + "::" + string (Env->PID))
        return;

      Api.reset_app ();

      if (This.has.sigint)
        signal (SIGINT, SIG_IGN, &handl);

      screen_size_changed = 0;
      signal (SIGWINCH, &__sigwinch_handler__);

      variable retval = self.reconnect_to_app (s.argv[0]);
      if (1 == retval)
        {
        __exit_rout__ (s, handl;;__qualifiers);
        return;
        }
      }
    else
      {
      variable defapp = This.is.my.settings["ON_RECONNECT_REQ_DEF_APPS"];
      ifnot (strlen (defapp))
        return;

      defapp = strtok (defapp, ",");

      variable j, app = NULL;
      _for j (0, length (defapp) - 1)
        ifnot (defapp[j] == This.is.my.name)
          {
          app = defapp[j];
          break;
          }

      if (NULL == app)
        return;

      Api.reset_app ();

      if (This.has.sigint)
        signal (SIGINT, SIG_IGN, &handl);

      signal (SIGWINCH, This.on.sigwinch);
      if (screen_size_changed)
        (@This.on.sigwinch) (SIGWINCH);

      self.connect_to_app (app;;__qualifiers);

      if (APP_ERR)
        {
        __exit_rout__ (s, handl;;__qualifiers);
        return;
        }
      }

    variable issu;

    forever
      {
      __APP__ = CUR_APP;
      retval = self.mainloop (&issu);
      if (Api->APP_RECON_OTH == retval)
        {
        retval = self.reconnect_to_app (__APP__);
        if (1 == retval)
          break;
        }
      else if (Api->APP_RECON_PREV == retval)
        {
        if (NULL == PREV_APP)
          break;
        retval = self.reconnect_to_app (PREV_APP);
        if (1 == retval)
          break;
        }
      else if (Api->APP_CON_NEW == retval)
        {
        self.connect_to_app (__APP__;issu = issu);
        if (APP_ERR)
          break;
        }
      else
        break;
      }

    __exit_rout__ (s, handl;;__qualifiers);
  end

  def mainloop (issu)
    if (NULL == __APP__)
      return 1;

    variable tok = strtok (__APP__, "::");
    variable app = tok[0];
    variable pid = tok[1];
    variable s = App->APPS[app][pid];

    forever
      {
      variable retval = Sock.get_int (SRV_FIFO_FD);

      if (Api->GO_ATEXIT == retval)
        {
        self.app_at_exit (s);
        break;
        }

      if (Api->GO_IDLED == retval)
        {
        s.state |= Api->IDLED;
        break;
        }

      if (Api->APP_GET_CONNECTED == retval)
        {
        Sock.send_str_ar (SRV_FIFO_FD, s.fd, get_connected_apps ());
        continue;
        }

      if (Api->APP_RECON_OTH == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        __APP__ = Sock.get_str (SRV_FIFO_FD);
        return retval;
        }

      if (Api->APP_RECON_PREV == retval)
        {
        s.state |= Api->IDLED;
        return retval;
        }

      if (Api->APP_CON_NEW == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        __APP__ = Sock.get_str (SRV_FIFO_FD);
        Sock.send_int (s.fd, 1);
        @issu = Sock.get_int (SRV_FIFO_FD);

        return retval;
        }
      }

    0;
  end

  def reconnect_to_app (k)
    variable tok = strtok (k, "::");
    variable app = tok[0];
    variable pid = tok[1];
    if (app == This.is.my.name && pid == string (Env->PID)
      || 0 == assoc_key_exists (App->APPS, app)
      || 0 == assoc_key_exists (App->APPS[app], pid))
      {
      __APP__ = NULL;
      return 1;
      }

    variable s = App->APPS[app][pid];
    PREV_APP = CUR_APP;
    CUR_APP = k;
    Sock.send_int (s.fd, 0);
    0;
  end

  def connect_to_app (app)
    ifnot (NULL == App->APPSINFO[app].set)
      if (any (app == CONNECTED_APPS))
        if (anynot (strncmp (App->APPSINFO[app].set, "unique:1", 8)))
          {
          APP_ERR = 1;
          return;
          }

    variable clfifo = This.is.my.tmpdir + "/__" + app + "_client_" +
      string (_time)[[5:]] + ".fifo";

    if (-1 == mkfifo (clfifo, 0755))
      {
      APP_ERR = 1;
      return;
      }

    variable argv = [app, NULL, NULL,
      __get_qualifier_as (AString_Type, qualifier ("argv"), String_Type[0])];

    if (This.request.profile)
      argv[1] = "--profile";

    if (This.request.debug)
      argv[2] = "--debug";

    variable clpid = App.Run.as.client (argv[wherenot (_isnull (argv))],
      SRV_FIFO, clfifo;;struct {@__qualifiers, bg});

    if (NULL == clpid)
      {
      () = remove (clfifo);
      APP_ERR = 1;
      return;
      }

    CONNECTED_APPS = [CONNECTED_APPS, app];
    CONNECTED_PIDS = [CONNECTED_PIDS, clpid];

    App->APPS[app][string (clpid)] = @App_Type;

    variable s = App->APPS[app][string (clpid)];
    s.fifo  = clfifo;
    s.pid   = clpid;
    s.state = Api->CONNECTED;
    s.name  = app;

    SRV_FIFO_FD = open (SRV_FIFO, O_RDONLY);
    s.fd        = open (clfifo, O_WRONLY);

    PREV_APP = CUR_APP;
    CUR_APP = app + "::" + string (s.pid);
  end
end
