subclass Srv
  __init__
    init
    app_at_exit
    mainloop
    appnew
    appreconnect
    idle
    reconnect_to_app
    connect_to_app
  end

  var SRV_FIFO    = NULL;
  var SRV_FIFO_FD = NULL;

  var CONNECTED_APPS = String_Type[0];
  var CONNECTED_PIDS = Integer_Type[0];

  var CHILDREN      = Assoc_Type[Assoc_Type];
  var CHILDREN_CON  = String_Type[0];
  var CHILDREN_PIDS = Integer_Type[0];
  var CHILD_CUR     = NULL;

  var CUR_APP = NULL;
  var PREV_APP = NULL;

  def idle ()
    exit_me (0);
  end

  def init ()
    SRV_FIFO = This.is.my.tmpdir + "/Session.fifo";
    if (-1 == mkfifo (SRV_FIFO, 0755))
      throw ClassError, "Srv::init::" + SRV_FIFO + " cannot crate fifo, " +
        errno_string (errno);
  end

  def app_at_exit (s)
    variable code = waitpid (s.pid, 0);

    variable ind = wherefirst_eq (CONNECTED_PIDS, s.pid);

    CONNECTED_PIDS[ind] = 0;
    CONNECTED_APPS[ind] = NULL;
    CONNECTED_PIDS = CONNECTED_PIDS[where (CONNECTED_PIDS)];
    CONNECTED_APPS = CONNECTED_APPS[wherenot (_isnull (CONNECTED_APPS))];

    () = close (s.fd);
    () = remove (s.fifo);
    assoc_delete_key (App->APPS[s.name], string (s.pid));
  end

  def appnew (s)
    variable apps = assoc_get_keys (App->APPS);
    variable retval;

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    () = Rline.commandcmp (s, apps);

    loop (1)
    {
    if (any (apps == s.argv[0]))
      self.connect_to_app (s.argv[0];;__qualifiers);
    else
      break;

    if (APP_ERR)
      break;

    forever
      {
      retval = self.mainloop ();
      if (Api->APP_RECON_OTH == retval)
        {
        retval = self.reconnect_to_app (CUR_APP);
        if (1 == retval)
          break 2;
        }
      else if (Api->APP_CON_NEW == retval)
        self.connect_to_app (CUR_APP);
      else
        break 2;
      }
    }

    Api.restore_screen ();

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def get_connected_apps () proc
    [This.is.my.name + "::" + string (Env->PID), array_map (
      String_Type, &sprintf, "%s::%d", CONNECTED_APPS, CONNECTED_PIDS)];
  end

  def appreconnect (s)
    variable apps = get_connected_apps ()[[1:]];
    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    () = Rline.commandcmp (s, apps);

    if (any (apps == s.argv[0]))
      {
      if (s.argv[0] == This.is.my.name + "::" + string (Env->PID))
        return;

      Api.reset_screen ();
      variable retval = self.reconnect_to_app (s.argv[0]);
      if (1 == retval)
        {
        Api.restore_screen ();
        Rline.set (s);
        Rline.prompt (s, s._lin, s._col);
        return;
        }
      }
    else
      return;

    forever
      {
      retval = self.mainloop ();
      if (Api->APP_RECON_OTH == retval)
        {
        retval = self.reconnect_to_app (CUR_APP);
        if (1 == retval)
          break;
        }
      else if (Api->APP_CON_NEW == retval)
        self.connect_to_app (CUR_APP);
      else
        break;
      }

    Api.restore_screen ();

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def mainloop ()
    if (NULL == CUR_APP)
      return;

    variable tok = strtok (CUR_APP, "::");
    variable app = tok[0];
    variable pid = tok[1];
    variable s = App->APPS[app][pid];

    forever
      {
      variable retval = Sock.get_int (SRV_FIFO_FD);

      if (Api->GO_ATEXIT == retval)
        {
        self.app_at_exit (s);
        break;
        }

      if (Api->GO_IDLED == retval)
        {
        s.state |= Api->IDLED;
        break;
        }

      if (Api->APP_GET_CONNECTED == retval)
        {
        Sock.send_str_ar (SRV_FIFO_FD, s.fd, get_connected_apps ());
        continue;
        }

      if (Api->APP_RECON_OTH == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        CUR_APP = Sock.get_str (SRV_FIFO_FD);
        return retval;
        }

      if (Api->APP_CON_NEW == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        CUR_APP = Sock.get_str (SRV_FIFO_FD);
        return retval;
        }
      }

    0;
  end

  def reconnect_to_app (k)
    variable tok = strtok (k, "::");
    variable app = tok[0];
    variable pid = tok[1];
    if (app == This.is.my.name && pid == string (Env->PID))
      {
      CUR_APP = NULL;
      return 1;
      }

    variable s = App->APPS[app][pid];
    PREV_APP = CUR_APP;
    CUR_APP = k;
    Sock.send_int (s.fd, 0);
    0;
  end

  def connect_to_app (app)
    variable clfifo = This.is.my.tmpdir + "/__" + app + "_client_" +
      string (_time)[[5:]] + ".fifo";

    () = mkfifo (clfifo, 0755);

    variable clpid = App.Run.as.client ([app], SRV_FIFO, clfifo;;
      struct {@__qualifiers, bg});

    if (NULL == clpid)
      {
      () = remove (clfifo);
      return;
      }

    SRV_FIFO_FD = open (SRV_FIFO, O_RDONLY);
    variable clfifo_fd = open (clfifo, O_WRONLY);

    CONNECTED_APPS = [CONNECTED_APPS, app];
    CONNECTED_PIDS = [CONNECTED_PIDS, clpid];

    App->APPS[app][string (clpid)] = @App_Type;

    variable s = App->APPS[app][string (clpid)];
    s.fifo  = clfifo;
    s.fd    = clfifo_fd;
    s.pid   = clpid;
    s.state = Api->CONNECTED;
    s.name  = app;

    PREV_APP = CUR_APP;
    CUR_APP = app + "::" + string (s.pid);
  end
end
