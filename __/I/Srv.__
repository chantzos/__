subclass Srv
  __init__
    init
    app_at_exit
    mainloop
    appnew
    appreconnect
    idle
    reconnect_to_app
    connect_to_app
  end

  var SRV_FIFO    = NULL;
  var SRV_FIFO_FD = NULL;

  var CONNECTED_APPS = String_Type[0];
  var CONNECTED_PIDS = Integer_Type[0];

  var CHILDREN      = Assoc_Type[Assoc_Type];
  var CHILDREN_CON  = String_Type[0];
  var CHILDREN_PIDS = Integer_Type[0];
  var CHILD_CUR     = NULL;

  var CUR_APP = NULL;
  var PREV_APP = NULL;

  def idle ()
    if (length (CONNECTED_APPS))
      {
      variable ret = IO.ask (["There are idled applications", "Do you really want to exit?",
        "y/n"], ['y', 'n']);
      if ('n' == ret)
        {
        variable rl = Ved.get_cur_rline ();
        Rline.prompt (rl, rl._lin, rl._col);
        return 0;
        }
      }

    exit_me (0);
  end

  def init ()
    SRV_FIFO = This.is.my.tmpdir + "/Session.fifo";
    if (-1 == mkfifo (SRV_FIFO, 0755))
      throw ClassError, "Srv::init::" + SRV_FIFO + " cannot crate fifo, " +
        errno_string (errno);
  end

  def app_at_exit (s)
    variable code = waitpid (s.pid, 0);

    variable ind = wherefirst_eq (CONNECTED_PIDS, s.pid);

    CONNECTED_PIDS[ind] = 0;
    CONNECTED_APPS[ind] = NULL;
    CONNECTED_PIDS = CONNECTED_PIDS[where (CONNECTED_PIDS)];
    CONNECTED_APPS = CONNECTED_APPS[wherenot (_isnull (CONNECTED_APPS))];

    () = close (s.fd);
    () = remove (s.fifo);
    assoc_delete_key (App->APPS[s.name], string (s.pid));
  end

  def appnew (s)
    variable apps = assoc_get_keys (App->APPS);
    variable retval, issu;

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    () = Rline.commandcmp (s, apps);

    if (This.has.sigint)
      {
      variable handl;
      signal (SIGINT, SIG_IGN, &handl);
      }

    loop (1)
    {
    if (any (apps == s.argv[0]))
      self.connect_to_app (s.argv[0];;__qualifiers);
    else
      break;

    if (APP_ERR)
      break;

    forever
      {
      retval = self.mainloop (&issu);
      if (Api->APP_RECON_OTH == retval)
        {
        retval = self.reconnect_to_app (CUR_APP);
        if (1 == retval)
          break 2;
        }
      else if (Api->APP_CON_NEW == retval)
        {
        self.connect_to_app (CUR_APP;issu = issu);
        if (APP_ERR)
          break 2;
        }
      else
        break 2;
      }
    }

    Api.restore_screen ();

    if (This.has.sigint)
      signal (SIGINT, handl);

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def get_connected_apps () proc
    [This.is.my.name + "::" + string (Env->PID), array_map (
      String_Type, &sprintf, "%s::%d", CONNECTED_APPS, CONNECTED_PIDS)];
  end

  def appreconnect (s)
    variable apps = get_connected_apps ()[[1:]];
    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    () = Rline.commandcmp (s, apps);

    variable handl;

    if (any (apps == s.argv[0]))
      {
      if (s.argv[0] == This.is.my.name + "::" + string (Env->PID))
        return;

      Api.reset_screen ();

      if (This.has.sigint)
        signal (SIGINT, SIG_IGN, &handl);

      variable retval = self.reconnect_to_app (s.argv[0]);
      if (1 == retval)
        {
        Api.restore_screen ();

        if (This.has.sigint)
          signal (SIGINT, handl);

        Rline.set (s);
        Rline.prompt (s, s._lin, s._col);
        return;
        }
      }
    else
      {
      variable a = This.is.my.genconf.set[wherenot (strncmp (
        This.is.my.genconf.set,
        "ON_RECONNECT_REQ_DEF_APPS::", strlen (
        "ON_RECONNECT_REQ_DEF_APPS::")))];

      ifnot (length (a))
        return;

      a = strtok (a[0], "::");
      ifnot (2 == length (a))
        return;

      a = strtok (a[1], ",");

      variable j, app = NULL;
      _for j (0, length (a) - 1)
        ifnot (a[j] == This.is.my.name)
          {
          app = a[j];
          break;
          }

      if (NULL == app)
        return;

      Api.reset_screen ();

      if (This.has.sigint)
        signal (SIGINT, SIG_IGN, &handl);

      self.connect_to_app (app;;__qualifiers);

      if (APP_ERR)
        {
        Api.restore_screen ();

        if (This.has.sigint)
          signal (SIGINT, handl);

        Rline.set (s);
        Rline.prompt (s, s._lin, s._col);
        return;
        }
      }

    variable issu;
    forever
      {
      retval = self.mainloop (&issu);
      if (Api->APP_RECON_OTH == retval)
        {
        retval = self.reconnect_to_app (CUR_APP);
        if (1 == retval)
          break;
        }
      else if (Api->APP_CON_NEW == retval)
        {
        self.connect_to_app (CUR_APP;issu = issu);
        if (APP_ERR)
          break;
        }
      else
        break;
      }

    Api.restore_screen ();

    if (This.has.sigint)
      signal (SIGINT, handl);

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def mainloop (issu)
    if (NULL == CUR_APP)
      return;

    variable tok = strtok (CUR_APP, "::");
    variable app = tok[0];
    variable pid = tok[1];
    variable s = App->APPS[app][pid];

    forever
      {
      variable retval = Sock.get_int (SRV_FIFO_FD);

      if (Api->GO_ATEXIT == retval)
        {
        self.app_at_exit (s);
        break;
        }

      if (Api->GO_IDLED == retval)
        {
        s.state |= Api->IDLED;
        break;
        }

      if (Api->APP_GET_CONNECTED == retval)
        {
        Sock.send_str_ar (SRV_FIFO_FD, s.fd, get_connected_apps ());
        continue;
        }

      if (Api->APP_RECON_OTH == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        CUR_APP = Sock.get_str (SRV_FIFO_FD);
        return retval;
        }

      if (Api->APP_CON_NEW == retval)
        {
        s.state |= Api->IDLED;
        Sock.send_int (s.fd, 1);
        CUR_APP = Sock.get_str (SRV_FIFO_FD);
        Sock.send_int (s.fd, 1);
        @issu = Sock.get_int (SRV_FIFO_FD);

        return retval;
        }
      }

    0;
  end

  def reconnect_to_app (k)
    variable tok = strtok (k, "::");
    variable app = tok[0];
    variable pid = tok[1];
    if (app == This.is.my.name && pid == string (Env->PID))
      {
      CUR_APP = NULL;
      return 1;
      }

    variable s = App->APPS[app][pid];
    PREV_APP = CUR_APP;
    CUR_APP = k;
    Sock.send_int (s.fd, 0);
    0;
  end

  def connect_to_app (app)
    ifnot (NULL == App->APPSINFO[app].set)
      {
      if (any (app == CONNECTED_APPS))
        if (($1 = app, Anon->Fun (`
            return any (0 == strncmp (App->APPSINFO[__tmp ($1)].set, "unique:1", 8));`)))
          {
          APP_ERR = 1;
          return;
          }
      }

    variable clfifo = This.is.my.tmpdir + "/__" + app + "_client_" +
      string (_time)[[5:]] + ".fifo";

    if (-1 == mkfifo (clfifo, 0755))
      {
      APP_ERR = 1;
      return;
      }

    variable clpid = App.Run.as.client ([app], SRV_FIFO, clfifo;;
      struct {@__qualifiers, bg});

    if (NULL == clpid)
      {
      () = remove (clfifo);
      APP_ERR = 1;
      return;
      }

    SRV_FIFO_FD = open (SRV_FIFO, O_RDONLY);
    variable clfifo_fd = open (clfifo, O_WRONLY);

    CONNECTED_APPS = [CONNECTED_APPS, app];
    CONNECTED_PIDS = [CONNECTED_PIDS, clpid];

    App->APPS[app][string (clpid)] = @App_Type;

    variable s = App->APPS[app][string (clpid)];
    s.fifo  = clfifo;
    s.fd    = clfifo_fd;
    s.pid   = clpid;
    s.state = Api->CONNECTED;
    s.name  = app;

    PREV_APP = CUR_APP;
    CUR_APP = app + "::" + string (s.pid);
  end
end
