class App
  typedef AppInfo
    help,
    info,
    dir,
    set,
  end

  typedef App
    fifo,
    fd,
    pid,
    state,
    name,
    argv,
  end

  var public SCRATCH_VED;
  var public ERR_VED;
  var public OUT_VED;
  var public OUTBG_VED;
  var public SOCKET;
  var public SCRATCH;
  var public STDOUTBG;
  var public GREPFILE;
  var public BGDIR;
  var public RDFIFO;
  var public WRFIFO;
  var public SCRATCHFD;
  var public STDOUTFDBG;
  var public RLINE = NULL;
  var public BGPIDS = Assoc_Type[Struct_Type];
  var public IARG = 0;
  var public ICOM = 0;
  var public NEEDSWINDDRAW = 0;
  var public EXITSTATUS = 0;

  var static PARENT_FIFO    = NULL;
  var static PARENT_FIFO_FD = NULL;
  var static CHILDREN       = Assoc_Type[App_Type];

  var static APPS     = Assoc_Type[Assoc_Type];
  var static APPSINFO = Assoc_Type[AppInfo_Type];

  let NOT_RUN_AS_SU = ["____"];

  def build_table ()
    variable i;
    variable ii;
    variable app;
    variable dir;
    variable apps;
    variable dirs = [Env->USER_APP_PATH, Env->STD_APP_PATH, Env->LOCAL_APP_PATH];

    _for i (0, length (dirs) - 1)
      {
      dir = dirs[i];
      apps = listdir (dir);
      if (NULL == apps || (NULL != apps && 0 == length (apps)))
        continue;

      apps = apps[where (array_map (Integer_Type, Dir.isdirectory,
        Dir, array_map (String_Type, &path_concat, dir, apps)))];

      _for ii (0, length (apps) - 1)
        {
        app = apps[ii];
        if (-1 == access (dir + "/" + app + "/" + app + ".sl", F_OK) &&
            -1 == access (dir + "/" + app + "/" + app + ".slc", F_OK))
          continue;

        APPSINFO[app] = @AppInfo_Type;
        APPSINFO[app].dir = dir + "/" + app;

        ifnot (access (dir + "/" + app + "/help.txt", F_OK|R_OK))
          APPSINFO[app].help = dir + "/" + app + "/help.txt";

        ifnot (access (dir + "/" + app + "/desc.txt", F_OK|R_OK))
          APPSINFO[app].info = dir + "/" + app + "/desc.txt";

        ifnot (access (dir + "/" + app + "/set", F_OK|R_OK))
          APPSINFO[app].set = File.readlines (dir + "/" + app + "/set");

        APPS[app] = Assoc_Type[App_Type];
        }
      }
  end

  def detach ()
    ifnot (This.is.me == "MASTER")
      Api.reset_app ();

    variable retval = (@__get_reference ("I->app_idle")) ();

    ifnot (retval)
      {
      ifnot (This.is.me == "MASTER")
        Api.restore_app ();
      return;
      }

    exit_me (0);
  end

  def quit_me ()
    ifnot (This.is.me == "MASTER")
      exit_me (0);

    () = (@__get_reference ("I->app_idle")) ();
  end

  subclass Run from App
  subclass Connect from App

  def child_reconnect (s) static proc
    ifnot (NULL == This.is.child)
      return;

    variable chs = assoc_get_keys (CHILDREN);
    ifnot (length (chs))
      return;

    variable i, ar = String_Type[length (chs)];
    _for i (0, length (chs) - 1)
      ar[i] = chs[i] + "::" + strjoin (CHILDREN[chs[i]].argv, " ");

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);

    if (Rline.commandcmp (s, ar;accept_one_len, accept_space_as_return,
        accept_ws) == 1)
      if (NULL != s.argv && length (s.argv) && strlen (s.argv[0]) &&
        (i = wherefirst (ar == s.argv[0]), NULL != i))
          App.Connect.to.child (chs[i]);

    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def __exit_children__ () proc
    variable chs = assoc_get_keys (CHILDREN);
    variable s, i;
    _for i (0, length (chs) - 1)
      {
      s = CHILDREN[chs[i]];
      Sock.send_int (s.fd, Api->GO_ATEXIT);
      () = waitpid (s.pid, 0);
      }
  end

  def _exit_ () public proc
    __exit_children__;

    if (__is_initialized (&Input))
      Input.at_exit ();

    if (__is_initialized (&Smg))
      Smg.at_exit ();

    variable rl = Ved.get_cur_rline ();

    ifnot (NULL == rl)
      Rline.writehistory (rl.history, rl.histfile);

    variable searchhist = (@__get_reference ("SEARCH_HISTORY"));

    if (length (searchhist))
      Rline.writehistory (list_to_array (searchhist), (@__get_reference ("SEARCH_HISTFILE")));
  end

  def draw (s) public proc
    variable st = NULL == s._fd ? lstat_file (s._abspath) : fstat (s._fd);

    if (NULL == st || (s.st_.st_size && st.st_atime == s.st_.st_atime
        && st.st_size == s.st_.st_size))
      ifnot (qualifier_exists ("force_a_redraw"))
        {
        s._i = s._ii;
        s.draw ();
        return;
        }

    s.st_ = st;
    s.lines = Ved.getlines (s._abspath, s._indent, st);

    s._len = length (s.lines) - 1;

    variable _i = qualifier ("_i");
    variable pos = qualifier ("pos");
    variable len = length (s.rows) - 1;

    ifnot (NULL == pos)
      (s.ptr[0] = pos[0], s.ptr[1] = pos[1]);
    else
      (s.ptr[1] = 0, s.ptr[0] = s._len + 1 <= len ? s.rows[0] : s.rows[-2]);

    ifnot (NULL == _i)
      s._i = _i;
    else
      s._i = s._len + 1 <= len ? 0 : s._len + 1 - len;

    s.draw ();
  end

  def viewfile (s, type, pos, _i) public proc
    variable ismsg = 0;
    Ved.setbuf (s._abspath);

    topline (" -- pager -- (" + type + " BUF) --";row =  s.ptr[0], col = s.ptr[1]);

    draw (s;pos = pos, _i = _i);

    forever
      {
      VEDCOUNT = -1;
      s._chr = Input.getch (;disable_langchange);

      if ('1' <= s._chr <= '9')
        {
        VEDCOUNT = "";

        while ('0' <= s._chr <= '9')
          {
          VEDCOUNT += char (s._chr);
          s._chr = Input.getch (;disable_langchange);
          }

        try
          VEDCOUNT = integer (VEDCOUNT);
        catch SyntaxError:
          {
          ismsg = 1;
          Smg.send_msg_dr ("count: too many digits >= " +
            string (256 * 256 * 256 * 128), 1, s.ptr[0], s.ptr[1]);
          continue;
          }
        }

      s.vedloopcallback ();

      if (ismsg)
        {
        Smg.send_msg_dr (" ", 0, s.ptr[0], s.ptr[1]);
        ismsg = 0;
        }

      if (any ([':', 'q'] == s._chr))
        break;
      }
  end

  def wind_mang (s) public proc
    (@__get_reference ("handle_w")) (Ved.get_cur_buf ());
    Rline.set (s);
    Rline.prompt (s, s._lin, s._col);
  end

  def toscratch (str) public proc
    IO.print (str;fd = SCRATCHFD);
  end

  def __eval () public proc
    Api.Eval.run (;;__qualifiers ());
  end

  def runcom (argv, issu) public proc
    variable rl = Ved.get_cur_rline ();
    variable commands = assoc_get_keys (rl.argvlist);
    variable orig = argv[0];

    ifnot (any (commands == argv[0]))
     ifnot (any (commands == (argv[0] = "~" + orig, argv[0])))
      ifnot (any (commands == (argv[0] = "`" + orig, argv[0])))
        {
        IO.tostderr (argv[0] + ": no such command");
        return;
        }

    rl.argv = argv;
    (@rl.argvlist[argv[0]].func) (rl.argv;;struct {issu = issu, @__qualifiers ()});
  end

  def scratch (ved)
    if (qualifier_exists ("draw") && qualifier ("draw") == 0)
    return;

    viewfile (SCRATCH_VED, "SCRATCH", [1, 0], 0);
    Ved.setbuf (ved._abspath);
    ved.draw ();

    NEEDSWINDDRAW = 1;
  end

  def send_msg_dr (msg) public proc
    Smg.send_msg_dr (msg, qualifier ("color", 0),
      qualifier ("row"), qualifier ("col"));
  end

  def __scratch (argv) public proc
    variable ved = @Ved.get_cur_buf ();

    App.scratch (ved);

    NEEDSWINDDRAW = 0;
    Ved.draw_wind ();
  end

  def __messages () public proc
    loop (_NARGS) pop ();
    variable ved = @Ved.get_cur_buf ();

    viewfile (ERR_VED, "MSG", NULL, NULL);
    Ved.setbuf (ved._abspath);

    Ved.draw_wind ();
  end
end
