class Root
  typedef App
    _sockaddr,
    _fd,
    _state,
    atexit,
    p_,
    uid,
    gid,
    _procfile,
    _appname,
    _appdir,
    argv,
  end

  typedef AppInfo
    init,
    help,
    info,
    dir,
  end

  import socket

  let OS_UID = NULL;
  let OS_GID = NULL;
  let OS_USER = NULL;
  let OS_GROUP = NULL;

  let LOGERR = 0x01;
  let LOGNORM = 0x02;
  let LOGALL = 0x04;
  let CONNECTED = 0x1;
  let IDLED = 0x2;
  let GO_ATEXIT = 0x0C8;
  let GO_IDLED =  0x012c;
  let RECONNECT = 0x0190;
  let APP_CON_NEW = 0x1f4;
  let APP_RECON_OTH = 0x258;
  let APP_GET_ALL = 0x2bc;
  let APP_GET_CONNECTED = 0x320;

  var public RLINE;
  var public ERR_VED;
  var public CONNECTED_APPS = String_Type[0];
  var public CONNECTED_PIDS = Integer_Type[0];
  var public CUR_IND = -1;
  var public APPS = Assoc_Type[Assoc_Type];
  var public APPSINFO = Assoc_Type[AppInfo_Type];
  var public _APPS_;
  var public VERBOSITY = 0;
  var public Setid_Type = struct
    {
    setid = 1,
    uid = OS_UID,
    gid = OS_GID,
    user = OS_USER,
    };

  do
    VERBOSITY |= (LOGNORM|LOGERR);
  end

  require topline from wind
  require root from wind

  def draw (s) public proc
    variable st = NULL == s._fd ? lstat_file (s._abspath) : fstat (s._fd);

    if (NULL == st ||
      (s.st_.st_size && st.st_atime == s.st_.st_atime && st.st_size == s.st_.st_size))
      {
      s._i = s._ii;
      s.draw ();
      return;
      }

    s.st_ = st;
    s.lines = Ved.__vgetlines (s._abspath, s._indent, st);

    s._len = length (s.lines) - 1;

    variable _i = qualifier ("_i");
    variable pos = qualifier ("pos");
    variable len = length (s.rows) - 1;

    ifnot (NULL == pos)
      (s.ptr[0] = pos[0], s.ptr[1] = pos[1]);
    else
      (s.ptr[1] = 0, s.ptr[0] = s._len + 1 <= len ? s.rows[0] : s.rows[-2]);

    ifnot (NULL == _i)
      s._i = _i;
    else
      s._i = s._len + 1 <= len ? 0 : s._len + 1 - len;

    s.draw ();
  end

  def viewfile (s, type, pos, _i) public proc
    variable ismsg = 0;
    Ved.__vsetbuf (s._abspath);

    topline (" -- pager -- (" + type + " BUF) --";row =  s.ptr[0], col = s.ptr[1]);

    draw (s;pos = pos, _i = _i);

    forever
      {
      VEDCOUNT = -1;
      s._chr = Input.getch (;disable_langchange);

      if ('1' <= s._chr <= '9')
        {
        VEDCOUNT = "";

        while ('0' <= s._chr <= '9')
          {
          VEDCOUNT += char (s._chr);
          s._chr = Input.getch (;disable_langchange);
          }

        try
          VEDCOUNT = integer (VEDCOUNT);
        catch SyntaxError:
          {
          ismsg = 1;
          Smg.send_msg_dr ("count: too many digits >= " +
            string (256 * 256 * 256 * 128), 1, s.ptr[0], s.ptr[1]);
          continue;
          }
        }

      s.vedloopcallback ();

      if (ismsg)
        {
        Smg.send_msg_dr (" ", 0, s.ptr[0], s.ptr[1]);
        ismsg = 0;
        }

      if (any ([':', 'q'] == s._chr))
        break;
      }
  end

  def __messages (argv) proc
    viewfile (ERR_VED, "OS", NULL, NULL);
  end

  def getloginname () proc
    strtrim_end (Rline.getline (;pchar = "login:"));
  end

  def login ()
    variable msg, uid, gid, group, user;

    user = getloginname ();

    (uid, gid) = Sys.setpwuidgid (user);

    group = Sys.setgrname (gid);

    variable passwd = self.getpasswd ();

    if (-1 == self.authenticate (user, passwd))
      This.err_handler ("authentication error");

    self.let ("OS_USER", user);
    self.let ("OS_UID", uid);
    self.let ("OS_GID", gid);
    self.let ("OS_GROUP", group);

    Os.let ("HASHEDDATA", Os.encryptpasswd (passwd));
  end

  def _log_ (str, logtype)
    if (VERBOSITY & logtype)
      IO.tostderr (str);
  end

  def __get_connected_app (app)
    ifnot (any (app == _APPS_))
      return String_Type[0];

    assoc_get_keys (APPS[app]);
  end

  def __reconnect_to_app (appl)
    variable pid = NULL;

    variable args = strtok (appl, "::");

    if (1 == length (args))
      return NULL;

    variable app = args[0];

    if (1 < length (args))
      pid = args[1];

    variable pids = self.__get_connected_app (app);

    ifnot (length (pids))
      return NULL;

    ifnot (NULL == pid)
      ifnot (any (pid == pids))
        return NULL;

    variable s = APPS[app][pid == NULL ? pids[0] : pid];

    s._state &= ~IDLED;

    s;
  end

  def __set_idled (s)
    s._state |= IDLED;
    self._log_ (s._appname + ": is in idled state", LOGERR);
  end

  def __send_reconnect (s)
    s._state &= ~IDLED;

    Sock.send_int (s._fd, RECONNECT);

    self._log_ (s._appname + ": with pid :" + string (s.p_.pid) + " reconnected", LOGNORM);
  end

  def __get_all_connected_apps ()
    variable i;
    variable ii;
    variable apps = {};

    _for i (0, length (_APPS_) - 1)
      {
      variable app = _APPS_[i];
      variable pids = self.__get_connected_app (app);
      if (length (pids))
        _for ii (0, length (pids) - 1)
          list_append (apps, [app, pids[ii]]);
      }

    list_to_array (apps, Array_Type);
  end

  def __get_con_apps ()
    variable pids = self.__get_all_connected_apps ();
    variable str = "";
    variable i;
    variable pid;

    _for i (0, length (pids) - 1)
      {
      pid = pids[i];
      str += sprintf ("%s::%d\n", pid[0], APPS[pid[0]][pid[1]].p_.pid);
      }

    str;
  end

  def __connect_to_app (s)
    while (-1 == access (s.appdir + "/__" + s._appname + "__.init", F_OK))
      ifnot (access (s.appdir + "/__" + s._appname + "__.initerr", F_OK))
        {
        () = remove (s.appdir + "/__" + s._appname + "__.initerr");

        s.p_.atexit ();

        () = kill (s.p_.pid, SIGKILL);

        self._log_ (s._appname +": evaluation err", LOGERR);

        IO.tostderr (IO.readlines (s.p_.stderr.file));

        return -1;
        }

    s._fd = s.p_.connect (s._sockaddr);

    if (NULL == s._fd)
      {
      s.p_.atexit ();

      () = kill (s.p_.pid, SIGKILL);

      self._log_ (s._appname +": failed to connect to socket", LOGERR);

      return -1;
      }

    s._state |= CONNECTED;

    self._log_ (s._appname + ": connected to socket", LOGNORM);

    APPS[s._appname][string (s.p_.pid)] = s;

    CUR_IND++;
    CONNECTED_APPS = [CONNECTED_APPS, s._appname];
    CONNECTED_PIDS = [CONNECTED_PIDS, s.p_.pid];

    0;
  end

  def __new_app (app)
    variable pids;

    ifnot (any (app == _APPS_))
      {
      IO.tostderr (app + ": No such application");
      return NULL;
      }

    variable setid = @Setid_Type;
    %variable lapp = Env->STD_APP_PATH + "/";
    %Load.file ("app/" + app, APPSINFO[app].init, app;err_handler = &__err_handler__, force);

    variable ref = __get_reference (app + "->" + app);
    variable s = (@ref) (;;struct {@setid, dont_connect});

    if (NULL == s)
      return NULL;

    if (-1 == self.__connect_to_app (s))
      return NULL;

    s;
  end

  def runapp () public proc
    variable argv = __pop_list (_NARGS);

    argv = list_to_array (argv, String_Type);

    variable app = qualifier ("argv0");

    ifnot (any (app == _APPS_))
      {
      IO.tostderr (app + ": No such application");
      return;
      }

    variable setid = @Setid_Type;

    variable issu = Opt.is_arg ("--su", argv);
    ifnot (NULL == issu)
      {
      setid.uid = 0;
      setid.gid = 0;
      setid.user = "root";
      argv[issu] = NULL;
      argv = argv[wherenot (_isnull (argv))];
      }

    variable args = {};
    variable i;

    _for i (0, length (argv) - 1)
      list_append (args, argv[i]);

    Smg.reset ();

%    load.from ("app/" + app, APPSINFO[app].init, app;
%      err_handler = &__err_handler__, force);

    variable ref = __get_reference (app + "->" + app);
    () = (@ref) (__push_list (args);;setid);

    Smg.init ();

    draw (ERR_VED);
  end

  def app_atexit (s)
    ifnot (s._state & IDLED)
      {
      variable status = waitpid (s.p_.pid, 0);

      s.p_.atexit ();

      ifnot (NULL == s._fd)
        () = close (s._fd);

      variable pid = s.p_.pid;

      assoc_delete_key (APPS[s._appname], string (s.p_.pid));

      variable ind = wherefirst_eq (CONNECTED_PIDS, pid);

      CONNECTED_PIDS[ind] = 0;
      CONNECTED_APPS[ind] = NULL;
      CONNECTED_PIDS = CONNECTED_PIDS[where (CONNECTED_PIDS)];
      CONNECTED_APPS = CONNECTED_APPS[wherenot (_isnull (CONNECTED_APPS))];
      CUR_IND = 0 == CUR_IND
        ? length (CONNECTED_APPS)
          ? length (CONNECTED_APPS) - 1
          : -1
        : CUR_IND - 1;

      self._log_ (s._appname + ": exited, EXIT_STATUS: " + string (status.exit_status), LOGERR);

      return;
      }

    self._log_ (s._appname + ": is in idled state", LOGERR);
  end

  def _get_s_ ()
    variable pid = string (CONNECTED_PIDS[CUR_IND]);
    variable app = CONNECTED_APPS[CUR_IND];
    APPS[app][pid];
  end

  def apploop (s)
    variable retval;
    variable app;

    forever
      {
      retval = Sock.get_int (s._fd);

      ifnot (Integer_Type == typeof (retval))
        {
        self._log_ (sprintf ("%s loop: expected Integer_Type, received %S", s._appname, typeof (retval)), LOGERR);
        return; %don't handled, but it should never happen
        }

      if (retval == APP_GET_ALL)
        {
        Sock.send_str (s._fd, strjoin (_APPS_, "\n"));
        continue;
        }

      if (retval == APP_GET_CONNECTED)
        {
        Sock.send_str (s._fd, self.__get_con_apps ());
        continue;
        }

      if (retval == GO_ATEXIT)
        {
        s._state &= ~CONNECTED;

        if (1 == length (CONNECTED_APPS))
          {
          self.app_atexit (s);
          return;
          }

        self.app_atexit (s);

        s = self._get_s_ ();

        self.__send_reconnect (s);
        continue;
        }

      if (retval == GO_IDLED)
        {
        self.__set_idled (s);
        return;
        }

      if (retval == APP_CON_NEW)
        {
        Sock.send_int (s._fd, 1);
        app = Sock.get_str (s._fd);

        self.__set_idled (s);

        s = self.__new_app (app);

        ifnot (NULL == s)
          continue;

        s = self._get_s_ ();

        self.__send_reconnect (s);
        continue;
        }

      if (retval == APP_RECON_OTH)
        {
        Sock.send_int (s._fd, 1);
        app = Sock.get_str (s._fd);

        self.__set_idled (s);

        s = self.__reconnect_to_app (app);

        if (NULL == s)
          {
          s = self._get_s_ ();

          self.__send_reconnect (s);
          continue;
          }

        self.__send_reconnect (s);
        continue;
        }
      }
  end

  def _addflags_ (p, s)
%    p.stderr.file = Dir->Vget ("TEMPDIR") + "/" + string (Env->Vget ("PID")) +
%      "Srv" + s._appname + "err";
    p.stderr.wr_flags = ">|";
  end

  def init_app (name, dir, argv)
    variable s = @App_Type;

    s._state = 0;
    s._appdir = dir;
    s._procfile = dir + "/proc";;
    s._appname = name;
    s.argv = argv;
    s._sockaddr = This.tempdir + "/" + string (Env->PID) + name + ".sock";

    self._log_ ("initing " + s._appname + ", sockaddress: " + s._sockaddr, LOGALL);

    s;
  end

  def _getargvenv_ (p, s, argv)
    argv = [Sys->SLSH_BIN, Env->STD_LIB_PATH + "/proc/rootproc.slc", s._procfile, argv];

    variable env = [Env.defenv (), sprintf ("SOCKADDR=%s", s._sockaddr)];

    argv, env;
  end

  def connect_to_child (s)
    if (-1 == self.__connect_to_app (s))
      return;

    self.apploop (s);
  end

  def doproc (s, argv)
    variable p, env;

    if (p = Proc.init (0, 0, 1;;__qualifiers ()), p == NULL)
      {
      self._log_ (s._appname + ": inited failed", LOGERR);
      return -1;
      }

    self._addflags_ (p, s);

    (argv, env) = self._getargvenv_ (p, s, argv);

    s.p_ = p;

    if (NULL == p.execve (argv, env, 1))
      {
      self._log_ (s._appname + ": fork failed", LOGERR);
      return -1;
      }

    self._log_ (s._appname  + " pid: " + string (s.p_.pid), LOGNORM);

    0;
  end

  def _exit_me_ (argv) proc
    variable i;
    variable s;
    variable ii;
    variable pid;
    variable app;
    variable pids;
    variable rl = qualifier ("rl");

    ifnot (NULL == rl)
      Rline.writehistory (rl.history, rl.histfile);

    _for i (0, length (_APPS_) - 1)
      {
      app = _APPS_[i];
      pids = assoc_get_keys (APPS[app]);
      _for ii (0, length (pids) - 1)
        {
        pid = pids[ii];
        s = APPS[app][pid];

        Sock.send_int (s._fd, 0);
        s._state &= ~IDLED;
        Root.app_atexit (s);
        }
      }

    exit_me (0);
  end

  def reconnect_toapp (argv) proc
    if (1 == length (argv))
      return;

    variable s = Root.__reconnect_to_app (argv[1]);

    if (NULL == s)
      return;

    Smg.reset ();

    Root.__send_reconnect (s);

    Root.apploop (s);

    Smg.init ();

    draw (ERR_VED);
  end

  def __my_eval () proc
    Api.eval ();
  end

  def init_commands () proc
    variable
      i,
      a = Assoc_Type[Argvlist_Type, @Argvlist_Type],
      apps = assoc_get_keys (APPS);

    _for i (0, length (apps) - 1)
      {
      variable app = apps[i];;

      a[app] = @Argvlist_Type;
      a[app].func = &runapp;
      a[app].type = "Func_Type";
      }

    a["q"] = @Argvlist_Type;
    a["q"].func = &_exit_me_;

    a["reconnect"] = @Argvlist_Type;
    a["reconnect"].func = &reconnect_toapp;

    a["eval"] = @Argvlist_Type;
    a["eval"].func = &__my_eval;
    a["eval"].type = "Func_Type";

    a["messages"] = @Argvlist_Type;
    a["messages"].func = &__messages;

    a;
  end

  def tabhook (s) proc
    ifnot (s._ind)
      return -1;

    ifnot (any (s.argv[0] == ["reconnect"]))
      return -1;

    variable pids = Root.__get_all_connected_apps ();

    ifnot (length (pids))
      return -1;

    variable i;
    variable arg;
    variable args = String_Type[0];

    _for i (0, length (pids) - 1)
      {
      arg = pids[i];
      args = [args, arg[0] +  "::" + string (APPS[arg[0]][arg[1]].p_.pid) + " void " +
      strjoin (APPS[arg[0]][arg[1]].argv, " ") + " connect to application"];
      }

    return Rline.argroutine (s;args = args, accept_ws);
  end

  def initrline () public proc
    return Rline.init (&init_commands;
      histfile = Env->USER_DATA_PATH + "/.__roothistory",
      tabhook = &tabhook,
      on_lang = &toplinedr,
      on_lang_args = {"-- OS --"});
  end

  def  _loop_ ()
    variable status = 0;
    try
      forever
        {
        Rline.set (RLINE);
        Rline.readline (RLINE);
        topline (" -- OS CONSOLE --" + " (depth " + string (_stkdepth ()) + ")");
        }
      catch AnyError:
        status = 1;

    if (status)
      throw RunTimeError, " ", __get_exception_info ();
  end

  def osloop ()
    forever
      try
        self._loop_ ();
      catch RunTimeError:
        {
        Exc.print (__get_exception_info);
        Smg.init ();
        draw (ERR_VED); % new func: draw_and_take_some_action
        }
  end

  def _apptable_ ()
    variable i;
    variable ii;
    variable app;
    variable dir;
    variable apps;
    variable dirs = [Env->USER_APP_PATH, Env->STD_APP_PATH];

    _for i (0, length (dirs) - 1)
      {
      dir = dirs[i];
      apps = listdir (dir);
      if (NULL == apps || (NULL != apps && 0 == length (apps)))
        continue;

      apps = apps[where (array_map (Integer_Type, Dir.isdirectory,
        Dir, array_map (String_Type, &path_concat, dir, apps)))];

      _for ii (0, length (apps) - 1)
        {
        app = apps[ii];
        if (-1 == access (dir + "/" + app + "/" + app + "Init.sl", F_OK)
          &&-1 == access (dir + "/" + app + "/" + app + "Init.slc", F_OK))
          continue;

        APPSINFO[app] = @AppInfo_Type;
        APPSINFO[app].init = app + "Init";
        APPSINFO[app].dir = dir + "/" + app;

        ifnot (access (dir + "/" + app + "/help.txt", F_OK))
          APPSINFO[app].help = dir + "/" + app + "/help.txt";

        ifnot (access (dir + "/" + app + "/info.txt", F_OK))
          APPSINFO[app].info = dir + "/" + app + "/info.txt";

        APPS[app] = Assoc_Type[App_Type];
        }
      }
  end

  def init_sys ()
    (VED_RLINE, VED_MAXFRAMES, VED_ISONLYPAGER) = 0, 1, 1;
    ERR_VED = Ved.init_ftype ("txt");
    (@__get_reference ("txt_settype")) (ERR_VED, This.stderrFn, VED_ROWS, NULL);
    Ved.__vsetbuf (ERR_VED._abspath);
    ERR_VED._fd = This.stderrFd;

    self._apptable_ ();

    _APPS_ = assoc_get_keys (APPS);

    RLINE = initrline ();
  end
end
